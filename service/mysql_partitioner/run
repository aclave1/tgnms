#!/bin/bash
# Check on Events partitions
MAX_EVENTS_PARTITIONS=15 # Number of days to keep for events
# Create partitions for today and tomorrow writes (if they dont exist)
for i in {0..1}
do
  PNAME=$(mysql cxl -e"SELECT DATE_FORMAT(NOW() + INTERVAL ${i} DAY, 'd_%Y_%m_%d')" -BsN)
  # ensure partition doesn't yet exist
  mysql cxl -e"SELECT PARTITION_NAME FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA = 'cxl' AND TABLE_NAME = 'events'"|grep -q $PNAME
  if [ "$?" -eq "1" ]; then
    LESS_THAN=$(mysql cxl -e"SELECT DATE_FORMAT(NOW() + INTERVAL ${i}+1 DAY, 'UNIX_TIMESTAMP(\'%Y-%m-%d 00:00:00\')')" -BsN)
    echo "Creating partition ${PNAME} in events with timestamp values less than ${LESS_THAN}"
    mysql cxl -e"ALTER TABLE events ADD PARTITION (partition ${PNAME} VALUES LESS THAN (${LESS_THAN}))" -BsN
  fi
done
# Clean-up old partitions
PART_COUNT=$(mysql cxl -e"SELECT PARTITION_NAME FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA = 'cxl' AND TABLE_NAME = 'events'" -BsN|wc -l)
if [ "$PART_COUNT" -gt "$MAX_EVENTS_PARTITIONS" ]
then
  CLEANUP_COUNT=$((PART_COUNT - $MAX_EVENTS_PARTITIONS))
  echo "Partition clean-up needed for events, dropping oldest ${CLEANUP_COUNT} partitions"
  PART_NAMES=$(mysql cxl -e"SELECT PARTITION_NAME FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA = 'cxl' AND TABLE_NAME = 'events'" -BsN|head -n ${CLEANUP_COUNT})
  for partition in $PART_NAMES
  do
    echo "Dropping events partition ${partition}"
    mysql cxl -e"ALTER TABLE events DROP PARTITION ${partition}"
  done
fi

# Check on Alerts partitions
MAX_ALERTS_PARTITIONS=15 # Number of days to keep for alerts
# Create partitions for today and tomorrow writes (if they dont exist)
for i in {0..1}
do
  PNAME=$(mysql cxl -e"SELECT DATE_FORMAT(NOW() + INTERVAL ${i} DAY, 'd_%Y_%m_%d')" -BsN)
  # ensure partition doesn't yet exist
  mysql cxl -e"SELECT PARTITION_NAME FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA = 'cxl' AND TABLE_NAME = 'alerts'"|grep -q $PNAME
  if [ "$?" -eq "1" ]; then
    LESS_THAN=$(mysql cxl -e"SELECT DATE_FORMAT(NOW() + INTERVAL ${i}+1 DAY, 'UNIX_TIMESTAMP(\'%Y-%m-%d 00:00:00\')')" -BsN)
    echo "Creating partition ${PNAME} in alerts with timestamp values less than ${LESS_THAN}"
    mysql cxl -e"ALTER TABLE alerts ADD PARTITION (partition ${PNAME} VALUES LESS THAN (${LESS_THAN}))" -BsN
  fi
done
# Clean-up old partitions
PART_COUNT=$(mysql cxl -e"SELECT PARTITION_NAME FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA = 'cxl' AND TABLE_NAME = 'alerts'" -BsN|wc -l)
if [ "$PART_COUNT" -gt "$MAX_ALERTS_PARTITIONS" ]
then
  CLEANUP_COUNT=$((PART_COUNT - $MAX_ALERTS_PARTITIONS))
  echo "Partition clean-up needed for alerts, dropping oldest ${CLEANUP_COUNT} partitions"
  PART_NAMES=$(mysql cxl -e"SELECT PARTITION_NAME FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA = 'cxl' AND TABLE_NAME = 'alerts'" -BsN|head -n ${CLEANUP_COUNT})
  for partition in $PART_NAMES
  do
    echo "Dropping alerts partition ${partition}"
    mysql cxl -e"ALTER TABLE alerts DROP PARTITION ${partition}"
  done
fi

# Clean old log files
LOG_FILE_PATH="/home/nms/data"
MAX_USED_GB=40
DATA_USED_GB=$(printf %.0f $(find /home/nms/data/ -type f -printf '%k\n'|awk '{SUM+=$1} END {print SUM/1000000}'))
if [ "$DATA_USED_GB" -gt "$MAX_USED_GB" ]; then
  # determine how much to delete
  GB_TO_DELETE=$(expr $DATA_USED_GB - $MAX_USED_GB)
  KB_TO_DELETE=$(expr $GB_TO_DELETE \* 1000000)
  echo "We need to delete ${GB_TO_DELETE}GB"
  # delete oldest files until we're below the threshold
  DELETE_TOTAL_KB=0
  while [ "$DELETE_TOTAL_KB" -lt "$KB_TO_DELETE" ]; do
    TOP_FILE=$(find $LOG_FILE_PATH -type f -printf '%T+ %k %p\n'|sort -n|head -1)
    TOP_FILE_NAME=$(echo $TOP_FILE|awk '{print $3}')
    TOP_FILE_KB=$(echo $TOP_FILE|awk '{print $2}')
    DELETE_TOTAL_KB=$(expr $DELETE_TOTAL_KB + $TOP_FILE_KB)
    echo -e "\tDeleting ${TOP_FILE_NAME} (${TOP_FILE_KB}KB) - Total (${DELETE_TOTAL_KB}/${KB_TO_DELETE}KB)"
    rm -f $TOP_FILE_NAME
  done
else
  echo "Log file disk usage okay (${DATA_USED_GB}/${MAX_USED_GB}GB)"
fi
