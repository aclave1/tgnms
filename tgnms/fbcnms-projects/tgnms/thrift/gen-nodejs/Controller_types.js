//
// Autogenerated by Thrift Compiler (0.11.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
'use strict';

const thrift = require('thrift');
const Thrift = thrift.Thrift;
const Q = thrift.Q;

const Lsdb_ttypes = require('./Lsdb_types');
const BWAllocation_ttypes = require('./BWAllocation_types');
const Topology_ttypes = require('./Topology_types');


const ttypes = module.exports = {};
ttypes.MessageType = {
  'GET_STATUS_DUMP' : 101,
  'REBOOT_REQUEST' : 102,
  'GET_CTRL_NEIGHBORS_REQ' : 103,
  'STATUS_DUMP' : 121,
  'GET_CTRL_NEIGHBORS_RESP' : 122,
  'GET_NEIGHBORS_RESP' : 123,
  'SET_NODE_PARAMS' : 141,
  'REBOOT_NODE' : 142,
  'GET_MINION_NEIGHBORS_REQ' : 143,
  'STATUS_REPORT' : 161,
  'STATUS_REPORT_ACK' : 162,
  'GET_MINION_NEIGHBORS_RESP' : 163,
  'GET_IGNITION_STATE' : 201,
  'SET_IGNITION_PARAMS' : 202,
  'SET_LINK_STATUS_REQ' : 203,
  'IGNITION_STATE' : 221,
  'SET_LINK_STATUS' : 241,
  'GET_LINK_STATUS' : 242,
  'LINK_STATUS' : 261,
  'GET_TOPOLOGY' : 301,
  'GET_NETWORK_AIRTIME' : 319,
  'SET_NODE_STATUS' : 302,
  'SET_NODE_MAC' : 303,
  'SET_NODE_MAC_LIST' : 315,
  'SET_NODE_PARAMS_REQ' : 304,
  'BUMP_LINKUP_ATTEMPTS' : 305,
  'ADD_NODE' : 306,
  'ADD_LINK' : 307,
  'DEL_NODE' : 308,
  'DEL_LINK' : 309,
  'ADD_SITE' : 310,
  'DEL_SITE' : 311,
  'EDIT_SITE' : 317,
  'EDIT_NODE' : 318,
  'SET_NETWORK_PARAMS_REQ' : 312,
  'RESET_TOPOLOGY_STATE' : 313,
  'SET_TOPOLOGY_NAME' : 314,
  'BULK_ADD' : 316,
  'GET_ROUTES' : 320,
  'TOPOLOGY' : 321,
  'NETWORK_AIRTIME' : 322,
  'GET_ROUTES_RESP' : 323,
  'UPGRADE_REQ' : 401,
  'SET_UPGRADE_STATUS' : 421,
  'UPGRADE_GROUP_REQ' : 441,
  'UPGRADE_STATE_REQ' : 442,
  'UPGRADE_ABORT_REQ' : 443,
  'UPGRADE_COMMIT_PLAN_REQ' : 444,
  'UPGRADE_ADD_IMAGE_REQ' : 445,
  'UPGRADE_DEL_IMAGE_REQ' : 446,
  'UPGRADE_LIST_IMAGES_REQ' : 447,
  'UPGRADE_STATE_DUMP' : 451,
  'UPGRADE_COMMIT_PLAN' : 452,
  'UPGRADE_LIST_IMAGES_RESP' : 453,
  'GET_MINION_CONFIG_REQ' : 721,
  'GET_MINION_CONFIG_RESP' : 722,
  'SET_MINION_CONFIG_REQ' : 723,
  'GET_MINION_CONFIG_ACTIONS_REQ' : 725,
  'GET_MINION_CONFIG_ACTIONS_RESP' : 726,
  'GET_CTRL_CONFIG_REQ' : 731,
  'GET_CTRL_CONFIG_RESP' : 732,
  'GET_CTRL_CONFIG_NODE_OVERRIDES_REQ' : 733,
  'GET_CTRL_CONFIG_NODE_OVERRIDES_RESP' : 734,
  'GET_CTRL_CONFIG_BASE_REQ' : 735,
  'GET_CTRL_CONFIG_BASE_RESP' : 736,
  'GET_CTRL_CONFIG_NETWORK_OVERRIDES_REQ' : 737,
  'GET_CTRL_CONFIG_NETWORK_OVERRIDES_RESP' : 738,
  'SET_CTRL_CONFIG_NODE_OVERRIDES_REQ' : 739,
  'SET_CTRL_CONFIG_NETWORK_OVERRIDES_REQ' : 740,
  'GET_CTRL_CONFIG_STATE_REQ' : 741,
  'GET_CTRL_CONFIG_STATE_RESP' : 742,
  'GET_CTRL_CONFIG_METADATA_REQ' : 743,
  'GET_CTRL_CONFIG_METADATA_RESP' : 744,
  'GET_CTRL_CONFIG_NETWORK_OVERRIDES_ACTIONS_REQ' : 745,
  'GET_CTRL_CONFIG_NODE_OVERRIDES_ACTIONS_REQ' : 746,
  'GET_CTRL_CONFIG_OVERRIDES_ACTIONS_RESP' : 747,
  'GET_CTRL_CONFIG_ACTIONS_RESULTS_REQ' : 748,
  'GET_CTRL_CONFIG_ACTIONS_RESULTS_RESP' : 749,
  'GET_CTRL_CONFIG_CONTROLLER_REQ' : 750,
  'GET_CTRL_CONFIG_CONTROLLER_RESP' : 751,
  'SET_CTRL_CONFIG_CONTROLLER_REQ' : 752,
  'GET_CTRL_CONFIG_CONTROLLER_METADATA_REQ' : 753,
  'GET_CTRL_CONFIG_CONTROLLER_METADATA_RESP' : 754,
  'SCAN_REQ' : 601,
  'SCAN_RESP' : 621,
  'START_SCAN' : 641,
  'GET_SCAN_STATUS' : 642,
  'RESET_SCAN_STATUS' : 643,
  'GET_SCAN_SCHEDULE' : 644,
  'SET_SCAN_SCHEDULE' : 645,
  'SCAN_STATUS' : 661,
  'SCAN_SCHEDULE' : 662,
  'GET_SLOT_MAP_CONFIG' : 701,
  'SET_SLOT_MAP_CONFIG' : 702,
  'SLOT_MAP_CONFIG' : 703,
  'DR_ACK' : 491,
  'GPS_GET_POS_RESP' : 492,
  'DR_DEV_ALLOC_RES' : 493,
  'GPS_GET_POS_REQ' : 495,
  'DR_DEV_ALLOC_REQ' : 496,
  'NODE_INIT' : 501,
  'DR_SET_LINK_STATUS' : 502,
  'FW_SET_NODE_PARAMS' : 503,
  'FW_STATS_CONFIGURE_REQ' : 504,
  'PHY_LA_CONFIG_REQ' : 505,
  'GPS_ENABLE_REQ' : 506,
  'FW_SET_CODEBOOK' : 507,
  'FW_DEBUG_REQ' : 508,
  'PHY_AGC_CONFIG_REQ' : 509,
  'PHY_GOLAY_SEQUENCE_CONFIG_REQ' : 510,
  'FW_CONFIG_REQ' : 511,
  'PHY_TPC_CONFIG_REQ' : 512,
  'FW_BF_RESP_SCAN' : 513,
  'NODE_INIT_NOTIFY' : 551,
  'DR_LINK_STATUS' : 552,
  'FW_STATS' : 553,
  'FW_ACK' : 591,
  'FW_HEALTHY' : 592,
  'FW_GET_CODEBOOK' : 593,
  'FW_CONFIG_RESP' : 594,
  'FW_ROUTING_INFO' : 595,
  'SYNC_LINK_MONITOR' : 801,
  'INJECT_KVSTORE_KEYS' : 802,
  'GET_ROUTING_ADJACENCIES' : 810,
  'ROUTING_ADJACENCIES' : 811,
  'SET_LINK_METRIC' : 812,
  'START_IPERF' : 901,
  'START_IPERF_RESP' : 902,
  'STOP_IPERF' : 903,
  'GET_IPERF_STATUS' : 904,
  'IPERF_STATUS' : 905,
  'START_IPERF_SERVER' : 911,
  'START_IPERF_CLIENT' : 912,
  'START_IPERF_SERVER_RESP' : 921,
  'IPERF_OUTPUT' : 922,
  'BSTAR_SYNC' : 1101,
  'BSTAR_FSM' : 1102,
  'BSTAR_GET_APP_DATA' : 1103,
  'BSTAR_APP_DATA' : 1104,
  'BSTAR_GET_STATE' : 1105,
  'BSTAR_SWITCH_CONTROLLER' : 1110,
  'NONE' : 1001,
  'HELLO' : 1002,
  'E2E_ACK' : 1003,
  'TEST' : 1004,
  'DR_RESP' : 1005,
  'DR_STAT_PUSH' : 1006,
};
ttypes.LinkActionType = {
  'LINK_UP' : 1,
  'LINK_DOWN' : 2,
  'LINK_ADD' : 3,
  'LINK_DELETE' : 4,
};
ttypes.LinkStatusType = {
  'LINK_UP' : 1,
  'LINK_DOWN' : 2,
};
ttypes.UpgradeStatusType = {
  'NONE' : 10,
  'DOWNLOADING_IMAGE' : 20,
  'DOWNLOAD_FAILED' : 30,
  'FLASHING_IMAGE' : 40,
  'FLASH_FAILED' : 50,
  'FLASHED' : 60,
  'COMMIT_FAILED' : 70,
};
ttypes.UpgradeReqType = {
  'PREPARE_UPGRADE' : 10,
  'COMMIT_UPGRADE' : 20,
  'RESET_STATUS' : 30,
};
ttypes.UpgradeGroupType = {
  'NODES' : 10,
  'NETWORK' : 20,
};
ttypes.CfgAction = {
  'NO_ACTION' : 0,
  'REBOOT' : 10,
  'RESTART_MINION' : 20,
  'RESTART_STATS_AGENT' : 21,
  'RESTART_LOGTAIL' : 22,
  'RESTART_OPENR' : 23,
  'SYNC_LINK_MONITOR' : 30,
  'INJECT_KVSTORE_KEYS' : 31,
};
ttypes.CfgParamType = {
  'INTEGER' : 10,
  'STRING' : 20,
  'BOOLEAN' : 30,
  'OBJECT' : 40,
  'MAP' : 50,
  'FLOAT' : 60,
};
ttypes.MinionNeighborState = {
  'PERMANENT' : 0,
  'NOARP' : 1,
  'REACHABLE' : 2,
  'STALE' : 3,
  'NONE' : 4,
  'INCOMPLETE' : 5,
  'DELAY' : 6,
  'PROBE' : 7,
  'FAILED' : 8,
  'UNKNOWN' : 9,
};
ttypes.ScanType = {
  'PBF' : 1,
  'IM' : 2,
  'RTCAL' : 3,
  'CBF_TX' : 4,
  'CBF_RX' : 5,
};
ttypes.ScanMode = {
  'COARSE' : 1,
  'FINE' : 2,
  'SELECTIVE' : 3,
};
ttypes.RTCal = {
  'NO_CAL' : 0,
  'TOP_RX_CAL' : 1,
  'TOP_TX_CAL' : 2,
  'BOT_RX_CAL' : 3,
  'BOT_TX_CAL' : 4,
  'VBS_RX_CAL' : 5,
  'VBS_TX_CAL' : 6,
};
ttypes.ScanFwStatus = {
  'COMPLETE' : 0,
  'INVALID_TYPE' : 1,
  'INVALID_START_TSF' : 2,
  'INVALID_STA' : 3,
  'AWV_IN_PROG' : 4,
  'STA_NOT_ASSOC' : 5,
  'REQ_BUFFER_FULL' : 6,
  'LINK_SHUT_DOWN' : 7,
  'UNKNOWN_ERROR' : 8,
};
ttypes.SlotPurpose = {
  'SP_IM' : 0,
  'SP_PBF' : 1,
  'SP_RTAC' : 2,
  'SP_VBF' : 3,
  'SP_NULLING' : 4,
  'SP_IGNITION' : 5,
  'SP_HYBRID_PBF' : 6,
};
ttypes.IperfTransportProtocol = {
  'TCP' : 6,
  'UDP' : 17,
};
ttypes.BinaryStarFsmState = {
  'STATE_PRIMARY' : 1,
  'STATE_BACKUP' : 2,
  'STATE_ACTIVE' : 3,
  'STATE_PASSIVE' : 4,
};
ttypes.BinaryStarFsmEvent = {
  'PEER_PRIMARY' : 1,
  'PEER_BACKUP' : 2,
  'PEER_ACTIVE' : 3,
  'PEER_PASSIVE' : 4,
  'CLIENT_REQUEST' : 5,
};
ttypes.CompressionFormat = {
  'SNAPPY' : 1,
};
const ImageMeta = module.exports.ImageMeta = function(args) {
  this.md5 = null;
  this.version = null;
  if (args) {
    if (args.md5 !== undefined && args.md5 !== null) {
      this.md5 = args.md5;
    }
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    }
  }
};
ImageMeta.prototype = {};
ImageMeta.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.md5 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.version = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ImageMeta.prototype.write = function(output) {
  output.writeStructBegin('ImageMeta');
  if (this.md5 !== null && this.md5 !== undefined) {
    output.writeFieldBegin('md5', Thrift.Type.STRING, 1);
    output.writeString(this.md5);
    output.writeFieldEnd();
  }
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.STRING, 2);
    output.writeString(this.version);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeStatus = module.exports.UpgradeStatus = function(args) {
  this.usType = null;
  this.nextImage = null;
  this.reason = null;
  this.upgradeReqId = null;
  this.whenToCommit = null;
  if (args) {
    if (args.usType !== undefined && args.usType !== null) {
      this.usType = args.usType;
    }
    if (args.nextImage !== undefined && args.nextImage !== null) {
      this.nextImage = new ttypes.ImageMeta(args.nextImage);
    }
    if (args.reason !== undefined && args.reason !== null) {
      this.reason = args.reason;
    }
    if (args.upgradeReqId !== undefined && args.upgradeReqId !== null) {
      this.upgradeReqId = args.upgradeReqId;
    }
    if (args.whenToCommit !== undefined && args.whenToCommit !== null) {
      this.whenToCommit = args.whenToCommit;
    }
  }
};
UpgradeStatus.prototype = {};
UpgradeStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.usType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.nextImage = new ttypes.ImageMeta();
        this.nextImage.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.reason = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.upgradeReqId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.whenToCommit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeStatus.prototype.write = function(output) {
  output.writeStructBegin('UpgradeStatus');
  if (this.usType !== null && this.usType !== undefined) {
    output.writeFieldBegin('usType', Thrift.Type.I32, 1);
    output.writeI32(this.usType);
    output.writeFieldEnd();
  }
  if (this.nextImage !== null && this.nextImage !== undefined) {
    output.writeFieldBegin('nextImage', Thrift.Type.STRUCT, 2);
    this.nextImage.write(output);
    output.writeFieldEnd();
  }
  if (this.reason !== null && this.reason !== undefined) {
    output.writeFieldBegin('reason', Thrift.Type.STRING, 3);
    output.writeString(this.reason);
    output.writeFieldEnd();
  }
  if (this.upgradeReqId !== null && this.upgradeReqId !== undefined) {
    output.writeFieldBegin('upgradeReqId', Thrift.Type.STRING, 4);
    output.writeString(this.upgradeReqId);
    output.writeFieldEnd();
  }
  if (this.whenToCommit !== null && this.whenToCommit !== undefined) {
    output.writeFieldBegin('whenToCommit', Thrift.Type.I64, 5);
    output.writeI64(this.whenToCommit);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeTorrentParams = module.exports.UpgradeTorrentParams = function(args) {
  this.downloadTimeout = null;
  this.downloadLimit = -1;
  this.uploadLimit = -1;
  this.maxConnections = -1;
  if (args) {
    if (args.downloadTimeout !== undefined && args.downloadTimeout !== null) {
      this.downloadTimeout = args.downloadTimeout;
    }
    if (args.downloadLimit !== undefined && args.downloadLimit !== null) {
      this.downloadLimit = args.downloadLimit;
    }
    if (args.uploadLimit !== undefined && args.uploadLimit !== null) {
      this.uploadLimit = args.uploadLimit;
    }
    if (args.maxConnections !== undefined && args.maxConnections !== null) {
      this.maxConnections = args.maxConnections;
    }
  }
};
UpgradeTorrentParams.prototype = {};
UpgradeTorrentParams.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.downloadTimeout = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.downloadLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.uploadLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I64) {
        this.maxConnections = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeTorrentParams.prototype.write = function(output) {
  output.writeStructBegin('UpgradeTorrentParams');
  if (this.downloadTimeout !== null && this.downloadTimeout !== undefined) {
    output.writeFieldBegin('downloadTimeout', Thrift.Type.I64, 1);
    output.writeI64(this.downloadTimeout);
    output.writeFieldEnd();
  }
  if (this.downloadLimit !== null && this.downloadLimit !== undefined) {
    output.writeFieldBegin('downloadLimit', Thrift.Type.I64, 2);
    output.writeI64(this.downloadLimit);
    output.writeFieldEnd();
  }
  if (this.uploadLimit !== null && this.uploadLimit !== undefined) {
    output.writeFieldBegin('uploadLimit', Thrift.Type.I64, 3);
    output.writeI64(this.uploadLimit);
    output.writeFieldEnd();
  }
  if (this.maxConnections !== null && this.maxConnections !== undefined) {
    output.writeFieldBegin('maxConnections', Thrift.Type.I64, 4);
    output.writeI64(this.maxConnections);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeReq = module.exports.UpgradeReq = function(args) {
  this.urType = null;
  this.upgradeReqId = null;
  this.md5 = null;
  this.imageUrl = null;
  this.scheduleToCommit = null;
  this.downloadAttempts = null;
  this.torrentParams = null;
  if (args) {
    if (args.urType !== undefined && args.urType !== null) {
      this.urType = args.urType;
    }
    if (args.upgradeReqId !== undefined && args.upgradeReqId !== null) {
      this.upgradeReqId = args.upgradeReqId;
    }
    if (args.md5 !== undefined && args.md5 !== null) {
      this.md5 = args.md5;
    }
    if (args.imageUrl !== undefined && args.imageUrl !== null) {
      this.imageUrl = args.imageUrl;
    }
    if (args.scheduleToCommit !== undefined && args.scheduleToCommit !== null) {
      this.scheduleToCommit = args.scheduleToCommit;
    }
    if (args.downloadAttempts !== undefined && args.downloadAttempts !== null) {
      this.downloadAttempts = args.downloadAttempts;
    }
    if (args.torrentParams !== undefined && args.torrentParams !== null) {
      this.torrentParams = new ttypes.UpgradeTorrentParams(args.torrentParams);
    }
  }
};
UpgradeReq.prototype = {};
UpgradeReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.urType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.upgradeReqId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.md5 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.imageUrl = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.scheduleToCommit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.downloadAttempts = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRUCT) {
        this.torrentParams = new ttypes.UpgradeTorrentParams();
        this.torrentParams.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeReq');
  if (this.urType !== null && this.urType !== undefined) {
    output.writeFieldBegin('urType', Thrift.Type.I32, 1);
    output.writeI32(this.urType);
    output.writeFieldEnd();
  }
  if (this.upgradeReqId !== null && this.upgradeReqId !== undefined) {
    output.writeFieldBegin('upgradeReqId', Thrift.Type.STRING, 2);
    output.writeString(this.upgradeReqId);
    output.writeFieldEnd();
  }
  if (this.md5 !== null && this.md5 !== undefined) {
    output.writeFieldBegin('md5', Thrift.Type.STRING, 3);
    output.writeString(this.md5);
    output.writeFieldEnd();
  }
  if (this.imageUrl !== null && this.imageUrl !== undefined) {
    output.writeFieldBegin('imageUrl', Thrift.Type.STRING, 4);
    output.writeString(this.imageUrl);
    output.writeFieldEnd();
  }
  if (this.scheduleToCommit !== null && this.scheduleToCommit !== undefined) {
    output.writeFieldBegin('scheduleToCommit', Thrift.Type.I64, 5);
    output.writeI64(this.scheduleToCommit);
    output.writeFieldEnd();
  }
  if (this.downloadAttempts !== null && this.downloadAttempts !== undefined) {
    output.writeFieldBegin('downloadAttempts', Thrift.Type.I64, 6);
    output.writeI64(this.downloadAttempts);
    output.writeFieldEnd();
  }
  if (this.torrentParams !== null && this.torrentParams !== undefined) {
    output.writeFieldBegin('torrentParams', Thrift.Type.STRUCT, 7);
    this.torrentParams.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeGroupReq = module.exports.UpgradeGroupReq = function(args) {
  this.ugType = null;
  this.nodes = null;
  this.excludeNodes = null;
  this.urReq = null;
  this.timeout = null;
  this.skipFailure = null;
  this.version = null;
  this.skipLinks = null;
  this.limit = null;
  this.retryLimit = 3;
  if (args) {
    if (args.ugType !== undefined && args.ugType !== null) {
      this.ugType = args.ugType;
    }
    if (args.nodes !== undefined && args.nodes !== null) {
      this.nodes = Thrift.copyList(args.nodes, [null]);
    }
    if (args.excludeNodes !== undefined && args.excludeNodes !== null) {
      this.excludeNodes = Thrift.copyList(args.excludeNodes, [null]);
    }
    if (args.urReq !== undefined && args.urReq !== null) {
      this.urReq = new ttypes.UpgradeReq(args.urReq);
    }
    if (args.timeout !== undefined && args.timeout !== null) {
      this.timeout = args.timeout;
    }
    if (args.skipFailure !== undefined && args.skipFailure !== null) {
      this.skipFailure = args.skipFailure;
    }
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    }
    if (args.skipLinks !== undefined && args.skipLinks !== null) {
      this.skipLinks = Thrift.copyList(args.skipLinks, [null]);
    }
    if (args.limit !== undefined && args.limit !== null) {
      this.limit = args.limit;
    }
    if (args.retryLimit !== undefined && args.retryLimit !== null) {
      this.retryLimit = args.retryLimit;
    }
  }
};
UpgradeGroupReq.prototype = {};
UpgradeGroupReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.ugType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size0 = 0;
        var _rtmp34;
        this.nodes = [];
        let _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (let _i5 = 0; _i5 < _size0; ++_i5) {
          let elem6 = null;
          elem6 = input.readString();
          this.nodes.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        let _size7 = 0;
        var _rtmp311;
        this.excludeNodes = [];
        let _etype10 = 0;
        _rtmp311 = input.readListBegin();
        _etype10 = _rtmp311.etype;
        _size7 = _rtmp311.size;
        for (let _i12 = 0; _i12 < _size7; ++_i12) {
          let elem13 = null;
          elem13 = input.readString();
          this.excludeNodes.push(elem13);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.urReq = new ttypes.UpgradeReq();
        this.urReq.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.timeout = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.BOOL) {
        this.skipFailure = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.version = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.LIST) {
        let _size14 = 0;
        var _rtmp318;
        this.skipLinks = [];
        let _etype17 = 0;
        _rtmp318 = input.readListBegin();
        _etype17 = _rtmp318.etype;
        _size14 = _rtmp318.size;
        for (let _i19 = 0; _i19 < _size14; ++_i19) {
          let elem20 = null;
          elem20 = input.readString();
          this.skipLinks.push(elem20);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I64) {
        this.limit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I64) {
        this.retryLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeGroupReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeGroupReq');
  if (this.ugType !== null && this.ugType !== undefined) {
    output.writeFieldBegin('ugType', Thrift.Type.I32, 1);
    output.writeI32(this.ugType);
    output.writeFieldEnd();
  }
  if (this.nodes !== null && this.nodes !== undefined) {
    output.writeFieldBegin('nodes', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.nodes.length);
    for (let iter21 in this.nodes) {
      if (this.nodes.hasOwnProperty(iter21)) {
        iter21 = this.nodes[iter21];
        output.writeString(iter21);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.excludeNodes !== null && this.excludeNodes !== undefined) {
    output.writeFieldBegin('excludeNodes', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRING, this.excludeNodes.length);
    for (let iter22 in this.excludeNodes) {
      if (this.excludeNodes.hasOwnProperty(iter22)) {
        iter22 = this.excludeNodes[iter22];
        output.writeString(iter22);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.urReq !== null && this.urReq !== undefined) {
    output.writeFieldBegin('urReq', Thrift.Type.STRUCT, 4);
    this.urReq.write(output);
    output.writeFieldEnd();
  }
  if (this.timeout !== null && this.timeout !== undefined) {
    output.writeFieldBegin('timeout', Thrift.Type.I64, 5);
    output.writeI64(this.timeout);
    output.writeFieldEnd();
  }
  if (this.skipFailure !== null && this.skipFailure !== undefined) {
    output.writeFieldBegin('skipFailure', Thrift.Type.BOOL, 6);
    output.writeBool(this.skipFailure);
    output.writeFieldEnd();
  }
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.STRING, 7);
    output.writeString(this.version);
    output.writeFieldEnd();
  }
  if (this.skipLinks !== null && this.skipLinks !== undefined) {
    output.writeFieldBegin('skipLinks', Thrift.Type.LIST, 8);
    output.writeListBegin(Thrift.Type.STRING, this.skipLinks.length);
    for (let iter23 in this.skipLinks) {
      if (this.skipLinks.hasOwnProperty(iter23)) {
        iter23 = this.skipLinks[iter23];
        output.writeString(iter23);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.limit !== null && this.limit !== undefined) {
    output.writeFieldBegin('limit', Thrift.Type.I64, 9);
    output.writeI64(this.limit);
    output.writeFieldEnd();
  }
  if (this.retryLimit !== null && this.retryLimit !== undefined) {
    output.writeFieldBegin('retryLimit', Thrift.Type.I64, 10);
    output.writeI64(this.retryLimit);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeStateReq = module.exports.UpgradeStateReq = function(args) {
};
UpgradeStateReq.prototype = {};
UpgradeStateReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeStateReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeStateReq');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeStateDump = module.exports.UpgradeStateDump = function(args) {
  this.curBatch = null;
  this.pendingBatches = null;
  this.curReq = null;
  this.pendingReqs = null;
  if (args) {
    if (args.curBatch !== undefined && args.curBatch !== null) {
      this.curBatch = Thrift.copyList(args.curBatch, [null]);
    }
    if (args.pendingBatches !== undefined && args.pendingBatches !== null) {
      this.pendingBatches = Thrift.copyList(args.pendingBatches, [Thrift.copyList, null]);
    }
    if (args.curReq !== undefined && args.curReq !== null) {
      this.curReq = new ttypes.UpgradeGroupReq(args.curReq);
    }
    if (args.pendingReqs !== undefined && args.pendingReqs !== null) {
      this.pendingReqs = Thrift.copyList(args.pendingReqs, [ttypes.UpgradeGroupReq]);
    }
  }
};
UpgradeStateDump.prototype = {};
UpgradeStateDump.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size24 = 0;
        var _rtmp328;
        this.curBatch = [];
        let _etype27 = 0;
        _rtmp328 = input.readListBegin();
        _etype27 = _rtmp328.etype;
        _size24 = _rtmp328.size;
        for (let _i29 = 0; _i29 < _size24; ++_i29) {
          let elem30 = null;
          elem30 = input.readString();
          this.curBatch.push(elem30);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size31 = 0;
        var _rtmp335;
        this.pendingBatches = [];
        let _etype34 = 0;
        _rtmp335 = input.readListBegin();
        _etype34 = _rtmp335.etype;
        _size31 = _rtmp335.size;
        for (let _i36 = 0; _i36 < _size31; ++_i36) {
          let elem37 = null;
          let _size38 = 0;
          var _rtmp342;
          elem37 = [];
          let _etype41 = 0;
          _rtmp342 = input.readListBegin();
          _etype41 = _rtmp342.etype;
          _size38 = _rtmp342.size;
          for (let _i43 = 0; _i43 < _size38; ++_i43) {
            let elem44 = null;
            elem44 = input.readString();
            elem37.push(elem44);
          }
          input.readListEnd();
          this.pendingBatches.push(elem37);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.curReq = new ttypes.UpgradeGroupReq();
        this.curReq.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        let _size45 = 0;
        var _rtmp349;
        this.pendingReqs = [];
        let _etype48 = 0;
        _rtmp349 = input.readListBegin();
        _etype48 = _rtmp349.etype;
        _size45 = _rtmp349.size;
        for (let _i50 = 0; _i50 < _size45; ++_i50) {
          let elem51 = null;
          elem51 = new ttypes.UpgradeGroupReq();
          elem51.read(input);
          this.pendingReqs.push(elem51);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeStateDump.prototype.write = function(output) {
  output.writeStructBegin('UpgradeStateDump');
  if (this.curBatch !== null && this.curBatch !== undefined) {
    output.writeFieldBegin('curBatch', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.curBatch.length);
    for (let iter52 in this.curBatch) {
      if (this.curBatch.hasOwnProperty(iter52)) {
        iter52 = this.curBatch[iter52];
        output.writeString(iter52);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.pendingBatches !== null && this.pendingBatches !== undefined) {
    output.writeFieldBegin('pendingBatches', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.LIST, this.pendingBatches.length);
    for (let iter53 in this.pendingBatches) {
      if (this.pendingBatches.hasOwnProperty(iter53)) {
        iter53 = this.pendingBatches[iter53];
        output.writeListBegin(Thrift.Type.STRING, iter53.length);
        for (let iter54 in iter53) {
          if (iter53.hasOwnProperty(iter54)) {
            iter54 = iter53[iter54];
            output.writeString(iter54);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.curReq !== null && this.curReq !== undefined) {
    output.writeFieldBegin('curReq', Thrift.Type.STRUCT, 3);
    this.curReq.write(output);
    output.writeFieldEnd();
  }
  if (this.pendingReqs !== null && this.pendingReqs !== undefined) {
    output.writeFieldBegin('pendingReqs', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.pendingReqs.length);
    for (let iter55 in this.pendingReqs) {
      if (this.pendingReqs.hasOwnProperty(iter55)) {
        iter55 = this.pendingReqs[iter55];
        iter55.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeAbortReq = module.exports.UpgradeAbortReq = function(args) {
  this.abortAll = null;
  this.reqIds = null;
  if (args) {
    if (args.abortAll !== undefined && args.abortAll !== null) {
      this.abortAll = args.abortAll;
    }
    if (args.reqIds !== undefined && args.reqIds !== null) {
      this.reqIds = Thrift.copyList(args.reqIds, [null]);
    }
  }
};
UpgradeAbortReq.prototype = {};
UpgradeAbortReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.abortAll = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size56 = 0;
        var _rtmp360;
        this.reqIds = [];
        let _etype59 = 0;
        _rtmp360 = input.readListBegin();
        _etype59 = _rtmp360.etype;
        _size56 = _rtmp360.size;
        for (let _i61 = 0; _i61 < _size56; ++_i61) {
          let elem62 = null;
          elem62 = input.readString();
          this.reqIds.push(elem62);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeAbortReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeAbortReq');
  if (this.abortAll !== null && this.abortAll !== undefined) {
    output.writeFieldBegin('abortAll', Thrift.Type.BOOL, 1);
    output.writeBool(this.abortAll);
    output.writeFieldEnd();
  }
  if (this.reqIds !== null && this.reqIds !== undefined) {
    output.writeFieldBegin('reqIds', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.reqIds.length);
    for (let iter63 in this.reqIds) {
      if (this.reqIds.hasOwnProperty(iter63)) {
        iter63 = this.reqIds[iter63];
        output.writeString(iter63);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeCommitPlanReq = module.exports.UpgradeCommitPlanReq = function(args) {
  this.limit = null;
  this.excludeNodes = null;
  if (args) {
    if (args.limit !== undefined && args.limit !== null) {
      this.limit = args.limit;
    }
    if (args.excludeNodes !== undefined && args.excludeNodes !== null) {
      this.excludeNodes = Thrift.copyList(args.excludeNodes, [null]);
    }
  }
};
UpgradeCommitPlanReq.prototype = {};
UpgradeCommitPlanReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.limit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size64 = 0;
        var _rtmp368;
        this.excludeNodes = [];
        let _etype67 = 0;
        _rtmp368 = input.readListBegin();
        _etype67 = _rtmp368.etype;
        _size64 = _rtmp368.size;
        for (let _i69 = 0; _i69 < _size64; ++_i69) {
          let elem70 = null;
          elem70 = input.readString();
          this.excludeNodes.push(elem70);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeCommitPlanReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeCommitPlanReq');
  if (this.limit !== null && this.limit !== undefined) {
    output.writeFieldBegin('limit', Thrift.Type.I64, 1);
    output.writeI64(this.limit);
    output.writeFieldEnd();
  }
  if (this.excludeNodes !== null && this.excludeNodes !== undefined) {
    output.writeFieldBegin('excludeNodes', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.excludeNodes.length);
    for (let iter71 in this.excludeNodes) {
      if (this.excludeNodes.hasOwnProperty(iter71)) {
        iter71 = this.excludeNodes[iter71];
        output.writeString(iter71);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeCommitPlan = module.exports.UpgradeCommitPlan = function(args) {
  this.commitBatches = null;
  this.canaryLinks = null;
  if (args) {
    if (args.commitBatches !== undefined && args.commitBatches !== null) {
      this.commitBatches = Thrift.copyList(args.commitBatches, [Thrift.copyList, null]);
    }
    if (args.canaryLinks !== undefined && args.canaryLinks !== null) {
      this.canaryLinks = Thrift.copyList(args.canaryLinks, [null]);
    }
  }
};
UpgradeCommitPlan.prototype = {};
UpgradeCommitPlan.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size72 = 0;
        var _rtmp376;
        this.commitBatches = [];
        let _etype75 = 0;
        _rtmp376 = input.readListBegin();
        _etype75 = _rtmp376.etype;
        _size72 = _rtmp376.size;
        for (let _i77 = 0; _i77 < _size72; ++_i77) {
          let elem78 = null;
          let _size79 = 0;
          var _rtmp383;
          elem78 = [];
          let _etype82 = 0;
          _rtmp383 = input.readListBegin();
          _etype82 = _rtmp383.etype;
          _size79 = _rtmp383.size;
          for (let _i84 = 0; _i84 < _size79; ++_i84) {
            let elem85 = null;
            elem85 = input.readString();
            elem78.push(elem85);
          }
          input.readListEnd();
          this.commitBatches.push(elem78);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size86 = 0;
        var _rtmp390;
        this.canaryLinks = [];
        let _etype89 = 0;
        _rtmp390 = input.readListBegin();
        _etype89 = _rtmp390.etype;
        _size86 = _rtmp390.size;
        for (let _i91 = 0; _i91 < _size86; ++_i91) {
          let elem92 = null;
          elem92 = input.readString();
          this.canaryLinks.push(elem92);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeCommitPlan.prototype.write = function(output) {
  output.writeStructBegin('UpgradeCommitPlan');
  if (this.commitBatches !== null && this.commitBatches !== undefined) {
    output.writeFieldBegin('commitBatches', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.LIST, this.commitBatches.length);
    for (let iter93 in this.commitBatches) {
      if (this.commitBatches.hasOwnProperty(iter93)) {
        iter93 = this.commitBatches[iter93];
        output.writeListBegin(Thrift.Type.STRING, iter93.length);
        for (let iter94 in iter93) {
          if (iter93.hasOwnProperty(iter94)) {
            iter94 = iter93[iter94];
            output.writeString(iter94);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.canaryLinks !== null && this.canaryLinks !== undefined) {
    output.writeFieldBegin('canaryLinks', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.canaryLinks.length);
    for (let iter95 in this.canaryLinks) {
      if (this.canaryLinks.hasOwnProperty(iter95)) {
        iter95 = this.canaryLinks[iter95];
        output.writeString(iter95);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeImage = module.exports.UpgradeImage = function(args) {
  this.name = null;
  this.magnetUri = null;
  this.md5 = null;
  if (args) {
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
    if (args.magnetUri !== undefined && args.magnetUri !== null) {
      this.magnetUri = args.magnetUri;
    }
    if (args.md5 !== undefined && args.md5 !== null) {
      this.md5 = args.md5;
    }
  }
};
UpgradeImage.prototype = {};
UpgradeImage.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.magnetUri = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.md5 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeImage.prototype.write = function(output) {
  output.writeStructBegin('UpgradeImage');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  if (this.magnetUri !== null && this.magnetUri !== undefined) {
    output.writeFieldBegin('magnetUri', Thrift.Type.STRING, 2);
    output.writeString(this.magnetUri);
    output.writeFieldEnd();
  }
  if (this.md5 !== null && this.md5 !== undefined) {
    output.writeFieldBegin('md5', Thrift.Type.STRING, 3);
    output.writeString(this.md5);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeAddImageReq = module.exports.UpgradeAddImageReq = function(args) {
  this.imageUrl = null;
  if (args) {
    if (args.imageUrl !== undefined && args.imageUrl !== null) {
      this.imageUrl = args.imageUrl;
    }
  }
};
UpgradeAddImageReq.prototype = {};
UpgradeAddImageReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.imageUrl = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeAddImageReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeAddImageReq');
  if (this.imageUrl !== null && this.imageUrl !== undefined) {
    output.writeFieldBegin('imageUrl', Thrift.Type.STRING, 1);
    output.writeString(this.imageUrl);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeDelImageReq = module.exports.UpgradeDelImageReq = function(args) {
  this.name = null;
  if (args) {
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
  }
};
UpgradeDelImageReq.prototype = {};
UpgradeDelImageReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeDelImageReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeDelImageReq');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeListImagesReq = module.exports.UpgradeListImagesReq = function(args) {
};
UpgradeListImagesReq.prototype = {};
UpgradeListImagesReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeListImagesReq.prototype.write = function(output) {
  output.writeStructBegin('UpgradeListImagesReq');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const UpgradeListImagesResp = module.exports.UpgradeListImagesResp = function(args) {
  this.images = null;
  if (args) {
    if (args.images !== undefined && args.images !== null) {
      this.images = Thrift.copyList(args.images, [ttypes.UpgradeImage]);
    }
  }
};
UpgradeListImagesResp.prototype = {};
UpgradeListImagesResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size96 = 0;
        var _rtmp3100;
        this.images = [];
        let _etype99 = 0;
        _rtmp3100 = input.readListBegin();
        _etype99 = _rtmp3100.etype;
        _size96 = _rtmp3100.size;
        for (let _i101 = 0; _i101 < _size96; ++_i101) {
          let elem102 = null;
          elem102 = new ttypes.UpgradeImage();
          elem102.read(input);
          this.images.push(elem102);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpgradeListImagesResp.prototype.write = function(output) {
  output.writeStructBegin('UpgradeListImagesResp');
  if (this.images !== null && this.images !== undefined) {
    output.writeFieldBegin('images', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.images.length);
    for (let iter103 in this.images) {
      if (this.images.hasOwnProperty(iter103)) {
        iter103 = this.images[iter103];
        iter103.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetMinionConfigReq = module.exports.GetMinionConfigReq = function(args) {
};
GetMinionConfigReq.prototype = {};
GetMinionConfigReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetMinionConfigReq.prototype.write = function(output) {
  output.writeStructBegin('GetMinionConfigReq');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetMinionConfigResp = module.exports.GetMinionConfigResp = function(args) {
  this.config = null;
  if (args) {
    if (args.config !== undefined && args.config !== null) {
      this.config = args.config;
    }
  }
};
GetMinionConfigResp.prototype = {};
GetMinionConfigResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.config = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetMinionConfigResp.prototype.write = function(output) {
  output.writeStructBegin('GetMinionConfigResp');
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRING, 1);
    output.writeString(this.config);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetMinionConfigReq = module.exports.SetMinionConfigReq = function(args) {
  this.config = null;
  if (args) {
    if (args.config !== undefined && args.config !== null) {
      this.config = args.config;
    }
  }
};
SetMinionConfigReq.prototype = {};
SetMinionConfigReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.config = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetMinionConfigReq.prototype.write = function(output) {
  output.writeStructBegin('SetMinionConfigReq');
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRING, 1);
    output.writeString(this.config);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetMinionConfigActionsReq = module.exports.GetMinionConfigActionsReq = function(args) {
  this.config = null;
  this.id = null;
  if (args) {
    if (args.config !== undefined && args.config !== null) {
      this.config = args.config;
    }
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    }
  }
};
GetMinionConfigActionsReq.prototype = {};
GetMinionConfigActionsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.config = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.id = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetMinionConfigActionsReq.prototype.write = function(output) {
  output.writeStructBegin('GetMinionConfigActionsReq');
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRING, 1);
    output.writeString(this.config);
    output.writeFieldEnd();
  }
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.STRING, 2);
    output.writeString(this.id);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetMinionConfigActionsResp = module.exports.GetMinionConfigActionsResp = function(args) {
  this.actions = null;
  this.id = null;
  if (args) {
    if (args.actions !== undefined && args.actions !== null) {
      this.actions = Thrift.copyList(args.actions, [null]);
    }
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    }
  }
};
GetMinionConfigActionsResp.prototype = {};
GetMinionConfigActionsResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.SET) {
        let _size104 = 0;
        var _rtmp3108;
        this.actions = [];
        let _etype107 = 0;
        _rtmp3108 = input.readSetBegin();
        _etype107 = _rtmp3108.etype;
        _size104 = _rtmp3108.size;
        for (let _i109 = 0; _i109 < _size104; ++_i109) {
          let elem110 = null;
          elem110 = input.readI32();
          this.actions.push(elem110);
        }
        input.readSetEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.id = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetMinionConfigActionsResp.prototype.write = function(output) {
  output.writeStructBegin('GetMinionConfigActionsResp');
  if (this.actions !== null && this.actions !== undefined) {
    output.writeFieldBegin('actions', Thrift.Type.SET, 1);
    output.writeSetBegin(Thrift.Type.I32, this.actions.length);
    for (let iter111 in this.actions) {
      if (this.actions.hasOwnProperty(iter111)) {
        iter111 = this.actions[iter111];
        output.writeI32(iter111);
      }
    }
    output.writeSetEnd();
    output.writeFieldEnd();
  }
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.STRING, 2);
    output.writeString(this.id);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigReq = module.exports.GetCtrlConfigReq = function(args) {
  this.node = null;
  this.swVersion = null;
  if (args) {
    if (args.node !== undefined && args.node !== null) {
      this.node = args.node;
    }
    if (args.swVersion !== undefined && args.swVersion !== null) {
      this.swVersion = args.swVersion;
    }
  }
};
GetCtrlConfigReq.prototype = {};
GetCtrlConfigReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.node = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.swVersion = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigReq');
  if (this.node !== null && this.node !== undefined) {
    output.writeFieldBegin('node', Thrift.Type.STRING, 1);
    output.writeString(this.node);
    output.writeFieldEnd();
  }
  if (this.swVersion !== null && this.swVersion !== undefined) {
    output.writeFieldBegin('swVersion', Thrift.Type.STRING, 2);
    output.writeString(this.swVersion);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigResp = module.exports.GetCtrlConfigResp = function(args) {
  this.config = null;
  if (args) {
    if (args.config !== undefined && args.config !== null) {
      this.config = args.config;
    }
  }
};
GetCtrlConfigResp.prototype = {};
GetCtrlConfigResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.config = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigResp');
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRING, 1);
    output.writeString(this.config);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigNodeOverridesReq = module.exports.GetCtrlConfigNodeOverridesReq = function(args) {
  this.nodes = null;
  if (args) {
    if (args.nodes !== undefined && args.nodes !== null) {
      this.nodes = Thrift.copyList(args.nodes, [null]);
    }
  }
};
GetCtrlConfigNodeOverridesReq.prototype = {};
GetCtrlConfigNodeOverridesReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size112 = 0;
        var _rtmp3116;
        this.nodes = [];
        let _etype115 = 0;
        _rtmp3116 = input.readListBegin();
        _etype115 = _rtmp3116.etype;
        _size112 = _rtmp3116.size;
        for (let _i117 = 0; _i117 < _size112; ++_i117) {
          let elem118 = null;
          elem118 = input.readString();
          this.nodes.push(elem118);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigNodeOverridesReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigNodeOverridesReq');
  if (this.nodes !== null && this.nodes !== undefined) {
    output.writeFieldBegin('nodes', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.nodes.length);
    for (let iter119 in this.nodes) {
      if (this.nodes.hasOwnProperty(iter119)) {
        iter119 = this.nodes[iter119];
        output.writeString(iter119);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigNodeOverridesResp = module.exports.GetCtrlConfigNodeOverridesResp = function(args) {
  this.overrides = null;
  if (args) {
    if (args.overrides !== undefined && args.overrides !== null) {
      this.overrides = args.overrides;
    }
  }
};
GetCtrlConfigNodeOverridesResp.prototype = {};
GetCtrlConfigNodeOverridesResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.overrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigNodeOverridesResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigNodeOverridesResp');
  if (this.overrides !== null && this.overrides !== undefined) {
    output.writeFieldBegin('overrides', Thrift.Type.STRING, 1);
    output.writeString(this.overrides);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetCtrlConfigNodeOverridesReq = module.exports.SetCtrlConfigNodeOverridesReq = function(args) {
  this.overrides = null;
  if (args) {
    if (args.overrides !== undefined && args.overrides !== null) {
      this.overrides = args.overrides;
    }
  }
};
SetCtrlConfigNodeOverridesReq.prototype = {};
SetCtrlConfigNodeOverridesReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.overrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetCtrlConfigNodeOverridesReq.prototype.write = function(output) {
  output.writeStructBegin('SetCtrlConfigNodeOverridesReq');
  if (this.overrides !== null && this.overrides !== undefined) {
    output.writeFieldBegin('overrides', Thrift.Type.STRING, 1);
    output.writeString(this.overrides);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigNodeOverridesActionsReq = module.exports.GetCtrlConfigNodeOverridesActionsReq = function(args) {
  this.overrides = null;
  if (args) {
    if (args.overrides !== undefined && args.overrides !== null) {
      this.overrides = args.overrides;
    }
  }
};
GetCtrlConfigNodeOverridesActionsReq.prototype = {};
GetCtrlConfigNodeOverridesActionsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.overrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigNodeOverridesActionsReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigNodeOverridesActionsReq');
  if (this.overrides !== null && this.overrides !== undefined) {
    output.writeFieldBegin('overrides', Thrift.Type.STRING, 1);
    output.writeString(this.overrides);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigBaseReq = module.exports.GetCtrlConfigBaseReq = function(args) {
  this.swVersions = null;
  if (args) {
    if (args.swVersions !== undefined && args.swVersions !== null) {
      this.swVersions = Thrift.copyList(args.swVersions, [null]);
    }
  }
};
GetCtrlConfigBaseReq.prototype = {};
GetCtrlConfigBaseReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size120 = 0;
        var _rtmp3124;
        this.swVersions = [];
        let _etype123 = 0;
        _rtmp3124 = input.readListBegin();
        _etype123 = _rtmp3124.etype;
        _size120 = _rtmp3124.size;
        for (let _i125 = 0; _i125 < _size120; ++_i125) {
          let elem126 = null;
          elem126 = input.readString();
          this.swVersions.push(elem126);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigBaseReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigBaseReq');
  if (this.swVersions !== null && this.swVersions !== undefined) {
    output.writeFieldBegin('swVersions', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.swVersions.length);
    for (let iter127 in this.swVersions) {
      if (this.swVersions.hasOwnProperty(iter127)) {
        iter127 = this.swVersions[iter127];
        output.writeString(iter127);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigBaseResp = module.exports.GetCtrlConfigBaseResp = function(args) {
  this.config = null;
  if (args) {
    if (args.config !== undefined && args.config !== null) {
      this.config = args.config;
    }
  }
};
GetCtrlConfigBaseResp.prototype = {};
GetCtrlConfigBaseResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.config = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigBaseResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigBaseResp');
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRING, 1);
    output.writeString(this.config);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigNetworkOverridesReq = module.exports.GetCtrlConfigNetworkOverridesReq = function(args) {
};
GetCtrlConfigNetworkOverridesReq.prototype = {};
GetCtrlConfigNetworkOverridesReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigNetworkOverridesReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigNetworkOverridesReq');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigNetworkOverridesResp = module.exports.GetCtrlConfigNetworkOverridesResp = function(args) {
  this.overrides = null;
  if (args) {
    if (args.overrides !== undefined && args.overrides !== null) {
      this.overrides = args.overrides;
    }
  }
};
GetCtrlConfigNetworkOverridesResp.prototype = {};
GetCtrlConfigNetworkOverridesResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.overrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigNetworkOverridesResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigNetworkOverridesResp');
  if (this.overrides !== null && this.overrides !== undefined) {
    output.writeFieldBegin('overrides', Thrift.Type.STRING, 1);
    output.writeString(this.overrides);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetCtrlConfigNetworkOverridesReq = module.exports.SetCtrlConfigNetworkOverridesReq = function(args) {
  this.overrides = null;
  if (args) {
    if (args.overrides !== undefined && args.overrides !== null) {
      this.overrides = args.overrides;
    }
  }
};
SetCtrlConfigNetworkOverridesReq.prototype = {};
SetCtrlConfigNetworkOverridesReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.overrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetCtrlConfigNetworkOverridesReq.prototype.write = function(output) {
  output.writeStructBegin('SetCtrlConfigNetworkOverridesReq');
  if (this.overrides !== null && this.overrides !== undefined) {
    output.writeFieldBegin('overrides', Thrift.Type.STRING, 1);
    output.writeString(this.overrides);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigNetworkOverridesActionsReq = module.exports.GetCtrlConfigNetworkOverridesActionsReq = function(args) {
  this.overrides = null;
  if (args) {
    if (args.overrides !== undefined && args.overrides !== null) {
      this.overrides = args.overrides;
    }
  }
};
GetCtrlConfigNetworkOverridesActionsReq.prototype = {};
GetCtrlConfigNetworkOverridesActionsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.overrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigNetworkOverridesActionsReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigNetworkOverridesActionsReq');
  if (this.overrides !== null && this.overrides !== undefined) {
    output.writeFieldBegin('overrides', Thrift.Type.STRING, 1);
    output.writeString(this.overrides);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigOverridesActionsResp = module.exports.GetCtrlConfigOverridesActionsResp = function(args) {
  this.overrides = null;
  this.id = null;
  this.availableUntil = null;
  if (args) {
    if (args.overrides !== undefined && args.overrides !== null) {
      this.overrides = args.overrides;
    }
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    }
    if (args.availableUntil !== undefined && args.availableUntil !== null) {
      this.availableUntil = args.availableUntil;
    }
  }
};
GetCtrlConfigOverridesActionsResp.prototype = {};
GetCtrlConfigOverridesActionsResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.overrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.id = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.availableUntil = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigOverridesActionsResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigOverridesActionsResp');
  if (this.overrides !== null && this.overrides !== undefined) {
    output.writeFieldBegin('overrides', Thrift.Type.STRING, 1);
    output.writeString(this.overrides);
    output.writeFieldEnd();
  }
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.STRING, 2);
    output.writeString(this.id);
    output.writeFieldEnd();
  }
  if (this.availableUntil !== null && this.availableUntil !== undefined) {
    output.writeFieldBegin('availableUntil', Thrift.Type.I64, 3);
    output.writeI64(this.availableUntil);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigActionsResultsReq = module.exports.GetCtrlConfigActionsResultsReq = function(args) {
  this.id = null;
  if (args) {
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    }
  }
};
GetCtrlConfigActionsResultsReq.prototype = {};
GetCtrlConfigActionsResultsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.id = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigActionsResultsReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigActionsResultsReq');
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.STRING, 1);
    output.writeString(this.id);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const NodeConfigActionsResult = module.exports.NodeConfigActionsResult = function(args) {
  this.actions = null;
  if (args) {
    if (args.actions !== undefined && args.actions !== null) {
      this.actions = Thrift.copyList(args.actions, [null]);
    }
  }
};
NodeConfigActionsResult.prototype = {};
NodeConfigActionsResult.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.SET) {
        let _size128 = 0;
        var _rtmp3132;
        this.actions = [];
        let _etype131 = 0;
        _rtmp3132 = input.readSetBegin();
        _etype131 = _rtmp3132.etype;
        _size128 = _rtmp3132.size;
        for (let _i133 = 0; _i133 < _size128; ++_i133) {
          let elem134 = null;
          elem134 = input.readI32();
          this.actions.push(elem134);
        }
        input.readSetEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NodeConfigActionsResult.prototype.write = function(output) {
  output.writeStructBegin('NodeConfigActionsResult');
  if (this.actions !== null && this.actions !== undefined) {
    output.writeFieldBegin('actions', Thrift.Type.SET, 1);
    output.writeSetBegin(Thrift.Type.I32, this.actions.length);
    for (let iter135 in this.actions) {
      if (this.actions.hasOwnProperty(iter135)) {
        iter135 = this.actions[iter135];
        output.writeI32(iter135);
      }
    }
    output.writeSetEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigActionsResultsResp = module.exports.GetCtrlConfigActionsResultsResp = function(args) {
  this.results = null;
  if (args) {
    if (args.results !== undefined && args.results !== null) {
      this.results = Thrift.copyMap(args.results, [ttypes.NodeConfigActionsResult]);
    }
  }
};
GetCtrlConfigActionsResultsResp.prototype = {};
GetCtrlConfigActionsResultsResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size136 = 0;
        var _rtmp3140;
        this.results = {};
        let _ktype137 = 0;
        let _vtype138 = 0;
        _rtmp3140 = input.readMapBegin();
        _ktype137 = _rtmp3140.ktype;
        _vtype138 = _rtmp3140.vtype;
        _size136 = _rtmp3140.size;
        for (let _i141 = 0; _i141 < _size136; ++_i141) {
          let key142 = null;
          let val143 = null;
          key142 = input.readString();
          val143 = new ttypes.NodeConfigActionsResult();
          val143.read(input);
          this.results[key142] = val143;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigActionsResultsResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigActionsResultsResp');
  if (this.results !== null && this.results !== undefined) {
    output.writeFieldBegin('results', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.results));
    for (const kiter144 in this.results) {
      if (this.results.hasOwnProperty(kiter144)) {
        const viter145 = this.results[kiter144];
        output.writeString(kiter144);
        viter145.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigStateReq = module.exports.GetCtrlConfigStateReq = function(args) {
};
GetCtrlConfigStateReq.prototype = {};
GetCtrlConfigStateReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigStateReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigStateReq');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const NodeConfigState = module.exports.NodeConfigState = function(args) {
  this.isManaged = null;
  this.lastStatusTime = null;
  this.lastConfigTime = null;
  this.ctrlMd5 = null;
  this.nodeMd5 = null;
  this.swVersion = null;
  if (args) {
    if (args.isManaged !== undefined && args.isManaged !== null) {
      this.isManaged = args.isManaged;
    }
    if (args.lastStatusTime !== undefined && args.lastStatusTime !== null) {
      this.lastStatusTime = args.lastStatusTime;
    }
    if (args.lastConfigTime !== undefined && args.lastConfigTime !== null) {
      this.lastConfigTime = args.lastConfigTime;
    }
    if (args.ctrlMd5 !== undefined && args.ctrlMd5 !== null) {
      this.ctrlMd5 = args.ctrlMd5;
    }
    if (args.nodeMd5 !== undefined && args.nodeMd5 !== null) {
      this.nodeMd5 = args.nodeMd5;
    }
    if (args.swVersion !== undefined && args.swVersion !== null) {
      this.swVersion = args.swVersion;
    }
  }
};
NodeConfigState.prototype = {};
NodeConfigState.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.isManaged = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.lastStatusTime = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.lastConfigTime = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.ctrlMd5 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.nodeMd5 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.swVersion = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NodeConfigState.prototype.write = function(output) {
  output.writeStructBegin('NodeConfigState');
  if (this.isManaged !== null && this.isManaged !== undefined) {
    output.writeFieldBegin('isManaged', Thrift.Type.BOOL, 1);
    output.writeBool(this.isManaged);
    output.writeFieldEnd();
  }
  if (this.lastStatusTime !== null && this.lastStatusTime !== undefined) {
    output.writeFieldBegin('lastStatusTime', Thrift.Type.I64, 2);
    output.writeI64(this.lastStatusTime);
    output.writeFieldEnd();
  }
  if (this.lastConfigTime !== null && this.lastConfigTime !== undefined) {
    output.writeFieldBegin('lastConfigTime', Thrift.Type.I64, 3);
    output.writeI64(this.lastConfigTime);
    output.writeFieldEnd();
  }
  if (this.ctrlMd5 !== null && this.ctrlMd5 !== undefined) {
    output.writeFieldBegin('ctrlMd5', Thrift.Type.STRING, 4);
    output.writeString(this.ctrlMd5);
    output.writeFieldEnd();
  }
  if (this.nodeMd5 !== null && this.nodeMd5 !== undefined) {
    output.writeFieldBegin('nodeMd5', Thrift.Type.STRING, 5);
    output.writeString(this.nodeMd5);
    output.writeFieldEnd();
  }
  if (this.swVersion !== null && this.swVersion !== undefined) {
    output.writeFieldBegin('swVersion', Thrift.Type.STRING, 6);
    output.writeString(this.swVersion);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigStateResp = module.exports.GetCtrlConfigStateResp = function(args) {
  this.configState = null;
  if (args) {
    if (args.configState !== undefined && args.configState !== null) {
      this.configState = Thrift.copyMap(args.configState, [ttypes.NodeConfigState]);
    }
  }
};
GetCtrlConfigStateResp.prototype = {};
GetCtrlConfigStateResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size146 = 0;
        var _rtmp3150;
        this.configState = {};
        let _ktype147 = 0;
        let _vtype148 = 0;
        _rtmp3150 = input.readMapBegin();
        _ktype147 = _rtmp3150.ktype;
        _vtype148 = _rtmp3150.vtype;
        _size146 = _rtmp3150.size;
        for (let _i151 = 0; _i151 < _size146; ++_i151) {
          let key152 = null;
          let val153 = null;
          key152 = input.readString();
          val153 = new ttypes.NodeConfigState();
          val153.read(input);
          this.configState[key152] = val153;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigStateResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigStateResp');
  if (this.configState !== null && this.configState !== undefined) {
    output.writeFieldBegin('configState', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.configState));
    for (const kiter154 in this.configState) {
      if (this.configState.hasOwnProperty(kiter154)) {
        const viter155 = this.configState[kiter154];
        output.writeString(kiter154);
        viter155.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigMetadata = module.exports.GetCtrlConfigMetadata = function(args) {
};
GetCtrlConfigMetadata.prototype = {};
GetCtrlConfigMetadata.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigMetadata.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigMetadata');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlConfigMetadataResp = module.exports.GetCtrlConfigMetadataResp = function(args) {
  this.metadata = null;
  if (args) {
    if (args.metadata !== undefined && args.metadata !== null) {
      this.metadata = args.metadata;
    }
  }
};
GetCtrlConfigMetadataResp.prototype = {};
GetCtrlConfigMetadataResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.metadata = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlConfigMetadataResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlConfigMetadataResp');
  if (this.metadata !== null && this.metadata !== undefined) {
    output.writeFieldBegin('metadata', Thrift.Type.STRING, 1);
    output.writeString(this.metadata);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const MinionConfigChanged = module.exports.MinionConfigChanged = function(args) {
};
MinionConfigChanged.prototype = {};
MinionConfigChanged.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

MinionConfigChanged.prototype.write = function(output) {
  output.writeStructBegin('MinionConfigChanged');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ControllerConfig = module.exports.ControllerConfig = function(args) {
  this.flags = null;
  if (args) {
    if (args.flags !== undefined && args.flags !== null) {
      this.flags = Thrift.copyMap(args.flags, [null]);
    }
  }
};
ControllerConfig.prototype = {};
ControllerConfig.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size156 = 0;
        var _rtmp3160;
        this.flags = {};
        let _ktype157 = 0;
        let _vtype158 = 0;
        _rtmp3160 = input.readMapBegin();
        _ktype157 = _rtmp3160.ktype;
        _vtype158 = _rtmp3160.vtype;
        _size156 = _rtmp3160.size;
        for (let _i161 = 0; _i161 < _size156; ++_i161) {
          let key162 = null;
          let val163 = null;
          key162 = input.readString();
          val163 = input.readString();
          this.flags[key162] = val163;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ControllerConfig.prototype.write = function(output) {
  output.writeStructBegin('ControllerConfig');
  if (this.flags !== null && this.flags !== undefined) {
    output.writeFieldBegin('flags', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.flags));
    for (const kiter164 in this.flags) {
      if (this.flags.hasOwnProperty(kiter164)) {
        const viter165 = this.flags[kiter164];
        output.writeString(kiter164);
        output.writeString(viter165);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlControllerConfigReq = module.exports.GetCtrlControllerConfigReq = function(args) {
};
GetCtrlControllerConfigReq.prototype = {};
GetCtrlControllerConfigReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlControllerConfigReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlControllerConfigReq');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlControllerConfigResp = module.exports.GetCtrlControllerConfigResp = function(args) {
  this.config = null;
  if (args) {
    if (args.config !== undefined && args.config !== null) {
      this.config = args.config;
    }
  }
};
GetCtrlControllerConfigResp.prototype = {};
GetCtrlControllerConfigResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.config = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlControllerConfigResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlControllerConfigResp');
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRING, 1);
    output.writeString(this.config);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetCtrlControllerConfigReq = module.exports.SetCtrlControllerConfigReq = function(args) {
  this.config = null;
  if (args) {
    if (args.config !== undefined && args.config !== null) {
      this.config = args.config;
    }
  }
};
SetCtrlControllerConfigReq.prototype = {};
SetCtrlControllerConfigReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.config = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetCtrlControllerConfigReq.prototype.write = function(output) {
  output.writeStructBegin('SetCtrlControllerConfigReq');
  if (this.config !== null && this.config !== undefined) {
    output.writeFieldBegin('config', Thrift.Type.STRING, 1);
    output.writeString(this.config);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlControllerConfigMetadata = module.exports.GetCtrlControllerConfigMetadata = function(args) {
};
GetCtrlControllerConfigMetadata.prototype = {};
GetCtrlControllerConfigMetadata.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlControllerConfigMetadata.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlControllerConfigMetadata');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlControllerConfigMetadataResp = module.exports.GetCtrlControllerConfigMetadataResp = function(args) {
  this.metadata = null;
  if (args) {
    if (args.metadata !== undefined && args.metadata !== null) {
      this.metadata = args.metadata;
    }
  }
};
GetCtrlControllerConfigMetadataResp.prototype = {};
GetCtrlControllerConfigMetadataResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.metadata = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlControllerConfigMetadataResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlControllerConfigMetadataResp');
  if (this.metadata !== null && this.metadata !== undefined) {
    output.writeFieldBegin('metadata', Thrift.Type.STRING, 1);
    output.writeString(this.metadata);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const RebootReq = module.exports.RebootReq = function(args) {
  this.nodes = null;
  this.force = null;
  this.secondsToReboot = null;
  if (args) {
    if (args.nodes !== undefined && args.nodes !== null) {
      this.nodes = Thrift.copyList(args.nodes, [null]);
    }
    if (args.force !== undefined && args.force !== null) {
      this.force = args.force;
    }
    if (args.secondsToReboot !== undefined && args.secondsToReboot !== null) {
      this.secondsToReboot = args.secondsToReboot;
    }
  }
};
RebootReq.prototype = {};
RebootReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size166 = 0;
        var _rtmp3170;
        this.nodes = [];
        let _etype169 = 0;
        _rtmp3170 = input.readListBegin();
        _etype169 = _rtmp3170.etype;
        _size166 = _rtmp3170.size;
        for (let _i171 = 0; _i171 < _size166; ++_i171) {
          let elem172 = null;
          elem172 = input.readString();
          this.nodes.push(elem172);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.force = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.secondsToReboot = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

RebootReq.prototype.write = function(output) {
  output.writeStructBegin('RebootReq');
  if (this.nodes !== null && this.nodes !== undefined) {
    output.writeFieldBegin('nodes', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.nodes.length);
    for (let iter173 in this.nodes) {
      if (this.nodes.hasOwnProperty(iter173)) {
        iter173 = this.nodes[iter173];
        output.writeString(iter173);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.force !== null && this.force !== undefined) {
    output.writeFieldBegin('force', Thrift.Type.BOOL, 2);
    output.writeBool(this.force);
    output.writeFieldEnd();
  }
  if (this.secondsToReboot !== null && this.secondsToReboot !== undefined) {
    output.writeFieldBegin('secondsToReboot', Thrift.Type.I32, 3);
    output.writeI32(this.secondsToReboot);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const RebootNode = module.exports.RebootNode = function(args) {
  this.force = null;
  this.secondsToReboot = 5;
  if (args) {
    if (args.force !== undefined && args.force !== null) {
      this.force = args.force;
    }
    if (args.secondsToReboot !== undefined && args.secondsToReboot !== null) {
      this.secondsToReboot = args.secondsToReboot;
    }
  }
};
RebootNode.prototype = {};
RebootNode.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.force = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.secondsToReboot = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

RebootNode.prototype.write = function(output) {
  output.writeStructBegin('RebootNode');
  if (this.force !== null && this.force !== undefined) {
    output.writeFieldBegin('force', Thrift.Type.BOOL, 1);
    output.writeBool(this.force);
    output.writeFieldEnd();
  }
  if (this.secondsToReboot !== null && this.secondsToReboot !== undefined) {
    output.writeFieldBegin('secondsToReboot', Thrift.Type.I32, 2);
    output.writeI32(this.secondsToReboot);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const NodeParams = module.exports.NodeParams = function(args) {
  this.bwAllocMap = null;
  this.polarity = null;
  this.golayIdx = null;
  this.location = null;
  this.airtimeAllocMap = null;
  this.enableGps = null;
  this.channel = null;
  if (args) {
    if (args.bwAllocMap !== undefined && args.bwAllocMap !== null) {
      this.bwAllocMap = new BWAllocation_ttypes.NodeBwAlloc(args.bwAllocMap);
    }
    if (args.polarity !== undefined && args.polarity !== null) {
      this.polarity = args.polarity;
    }
    if (args.golayIdx !== undefined && args.golayIdx !== null) {
      this.golayIdx = new Topology_ttypes.GolayIdx(args.golayIdx);
    }
    if (args.location !== undefined && args.location !== null) {
      this.location = new Topology_ttypes.Location(args.location);
    }
    if (args.airtimeAllocMap !== undefined && args.airtimeAllocMap !== null) {
      this.airtimeAllocMap = new BWAllocation_ttypes.NodeAirtime(args.airtimeAllocMap);
    }
    if (args.enableGps !== undefined && args.enableGps !== null) {
      this.enableGps = args.enableGps;
    }
    if (args.channel !== undefined && args.channel !== null) {
      this.channel = args.channel;
    }
  }
};
NodeParams.prototype = {};
NodeParams.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.bwAllocMap = new BWAllocation_ttypes.NodeBwAlloc();
        this.bwAllocMap.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.polarity = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.golayIdx = new Topology_ttypes.GolayIdx();
        this.golayIdx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.location = new Topology_ttypes.Location();
        this.location.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.airtimeAllocMap = new BWAllocation_ttypes.NodeAirtime();
        this.airtimeAllocMap.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.BOOL) {
        this.enableGps = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.BYTE) {
        this.channel = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NodeParams.prototype.write = function(output) {
  output.writeStructBegin('NodeParams');
  if (this.bwAllocMap !== null && this.bwAllocMap !== undefined) {
    output.writeFieldBegin('bwAllocMap', Thrift.Type.STRUCT, 1);
    this.bwAllocMap.write(output);
    output.writeFieldEnd();
  }
  if (this.polarity !== null && this.polarity !== undefined) {
    output.writeFieldBegin('polarity', Thrift.Type.I32, 2);
    output.writeI32(this.polarity);
    output.writeFieldEnd();
  }
  if (this.golayIdx !== null && this.golayIdx !== undefined) {
    output.writeFieldBegin('golayIdx', Thrift.Type.STRUCT, 3);
    this.golayIdx.write(output);
    output.writeFieldEnd();
  }
  if (this.location !== null && this.location !== undefined) {
    output.writeFieldBegin('location', Thrift.Type.STRUCT, 4);
    this.location.write(output);
    output.writeFieldEnd();
  }
  if (this.airtimeAllocMap !== null && this.airtimeAllocMap !== undefined) {
    output.writeFieldBegin('airtimeAllocMap', Thrift.Type.STRUCT, 5);
    this.airtimeAllocMap.write(output);
    output.writeFieldEnd();
  }
  if (this.enableGps !== null && this.enableGps !== undefined) {
    output.writeFieldBegin('enableGps', Thrift.Type.BOOL, 6);
    output.writeBool(this.enableGps);
    output.writeFieldEnd();
  }
  if (this.channel !== null && this.channel !== undefined) {
    output.writeFieldBegin('channel', Thrift.Type.BYTE, 7);
    output.writeByte(this.channel);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StatusReport = module.exports.StatusReport = function(args) {
  this.timeStamp = null;
  this.ipv6Address = null;
  this.version = null;
  this.ubootVersion = null;
  this.status = null;
  this.upgradeStatus = null;
  this.configMd5 = null;
  this.nodeIsPrimary = null;
  if (args) {
    if (args.timeStamp !== undefined && args.timeStamp !== null) {
      this.timeStamp = args.timeStamp;
    }
    if (args.ipv6Address !== undefined && args.ipv6Address !== null) {
      this.ipv6Address = args.ipv6Address;
    }
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    }
    if (args.ubootVersion !== undefined && args.ubootVersion !== null) {
      this.ubootVersion = args.ubootVersion;
    }
    if (args.status !== undefined && args.status !== null) {
      this.status = args.status;
    }
    if (args.upgradeStatus !== undefined && args.upgradeStatus !== null) {
      this.upgradeStatus = new ttypes.UpgradeStatus(args.upgradeStatus);
    }
    if (args.configMd5 !== undefined && args.configMd5 !== null) {
      this.configMd5 = args.configMd5;
    }
    if (args.nodeIsPrimary !== undefined && args.nodeIsPrimary !== null) {
      this.nodeIsPrimary = args.nodeIsPrimary;
    }
  }
};
StatusReport.prototype = {};
StatusReport.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.timeStamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.ipv6Address = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.version = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.ubootVersion = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.upgradeStatus = new ttypes.UpgradeStatus();
        this.upgradeStatus.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.configMd5 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.BOOL) {
        this.nodeIsPrimary = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StatusReport.prototype.write = function(output) {
  output.writeStructBegin('StatusReport');
  if (this.timeStamp !== null && this.timeStamp !== undefined) {
    output.writeFieldBegin('timeStamp', Thrift.Type.I64, 1);
    output.writeI64(this.timeStamp);
    output.writeFieldEnd();
  }
  if (this.ipv6Address !== null && this.ipv6Address !== undefined) {
    output.writeFieldBegin('ipv6Address', Thrift.Type.STRING, 2);
    output.writeString(this.ipv6Address);
    output.writeFieldEnd();
  }
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.STRING, 3);
    output.writeString(this.version);
    output.writeFieldEnd();
  }
  if (this.ubootVersion !== null && this.ubootVersion !== undefined) {
    output.writeFieldBegin('ubootVersion', Thrift.Type.STRING, 6);
    output.writeString(this.ubootVersion);
    output.writeFieldEnd();
  }
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 4);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.upgradeStatus !== null && this.upgradeStatus !== undefined) {
    output.writeFieldBegin('upgradeStatus', Thrift.Type.STRUCT, 5);
    this.upgradeStatus.write(output);
    output.writeFieldEnd();
  }
  if (this.configMd5 !== null && this.configMd5 !== undefined) {
    output.writeFieldBegin('configMd5', Thrift.Type.STRING, 7);
    output.writeString(this.configMd5);
    output.writeFieldEnd();
  }
  if (this.nodeIsPrimary !== null && this.nodeIsPrimary !== undefined) {
    output.writeFieldBegin('nodeIsPrimary', Thrift.Type.BOOL, 8);
    output.writeBool(this.nodeIsPrimary);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StatusReportAck = module.exports.StatusReportAck = function(args) {
};
StatusReportAck.prototype = {};
StatusReportAck.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StatusReportAck.prototype.write = function(output) {
  output.writeStructBegin('StatusReportAck');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetStatusDump = module.exports.GetStatusDump = function(args) {
};
GetStatusDump.prototype = {};
GetStatusDump.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetStatusDump.prototype.write = function(output) {
  output.writeStructBegin('GetStatusDump');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StatusDump = module.exports.StatusDump = function(args) {
  this.timeStamp = null;
  this.statusReports = null;
  this.version = null;
  if (args) {
    if (args.timeStamp !== undefined && args.timeStamp !== null) {
      this.timeStamp = args.timeStamp;
    }
    if (args.statusReports !== undefined && args.statusReports !== null) {
      this.statusReports = Thrift.copyMap(args.statusReports, [ttypes.StatusReport]);
    }
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    }
  }
};
StatusDump.prototype = {};
StatusDump.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.timeStamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.MAP) {
        let _size174 = 0;
        var _rtmp3178;
        this.statusReports = {};
        let _ktype175 = 0;
        let _vtype176 = 0;
        _rtmp3178 = input.readMapBegin();
        _ktype175 = _rtmp3178.ktype;
        _vtype176 = _rtmp3178.vtype;
        _size174 = _rtmp3178.size;
        for (let _i179 = 0; _i179 < _size174; ++_i179) {
          let key180 = null;
          let val181 = null;
          key180 = input.readString();
          val181 = new ttypes.StatusReport();
          val181.read(input);
          this.statusReports[key180] = val181;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.version = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StatusDump.prototype.write = function(output) {
  output.writeStructBegin('StatusDump');
  if (this.timeStamp !== null && this.timeStamp !== undefined) {
    output.writeFieldBegin('timeStamp', Thrift.Type.I64, 1);
    output.writeI64(this.timeStamp);
    output.writeFieldEnd();
  }
  if (this.statusReports !== null && this.statusReports !== undefined) {
    output.writeFieldBegin('statusReports', Thrift.Type.MAP, 2);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.statusReports));
    for (const kiter182 in this.statusReports) {
      if (this.statusReports.hasOwnProperty(kiter182)) {
        const viter183 = this.statusReports[kiter182];
        output.writeString(kiter182);
        viter183.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.STRING, 3);
    output.writeString(this.version);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlNeighborsReq = module.exports.GetCtrlNeighborsReq = function(args) {
  this.devices = null;
  if (args) {
    if (args.devices !== undefined && args.devices !== null) {
      this.devices = Thrift.copyList(args.devices, [null]);
    }
  }
};
GetCtrlNeighborsReq.prototype = {};
GetCtrlNeighborsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size184 = 0;
        var _rtmp3188;
        this.devices = [];
        let _etype187 = 0;
        _rtmp3188 = input.readListBegin();
        _etype187 = _rtmp3188.etype;
        _size184 = _rtmp3188.size;
        for (let _i189 = 0; _i189 < _size184; ++_i189) {
          let elem190 = null;
          elem190 = input.readString();
          this.devices.push(elem190);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlNeighborsReq.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlNeighborsReq');
  if (this.devices !== null && this.devices !== undefined) {
    output.writeFieldBegin('devices', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.devices.length);
    for (let iter191 in this.devices) {
      if (this.devices.hasOwnProperty(iter191)) {
        iter191 = this.devices[iter191];
        output.writeString(iter191);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetCtrlNeighborsResp = module.exports.GetCtrlNeighborsResp = function(args) {
  this.devices = null;
  this.reqId = null;
  if (args) {
    if (args.devices !== undefined && args.devices !== null) {
      this.devices = Thrift.copyList(args.devices, [null]);
    }
    if (args.reqId !== undefined && args.reqId !== null) {
      this.reqId = args.reqId;
    }
  }
};
GetCtrlNeighborsResp.prototype = {};
GetCtrlNeighborsResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size192 = 0;
        var _rtmp3196;
        this.devices = [];
        let _etype195 = 0;
        _rtmp3196 = input.readListBegin();
        _etype195 = _rtmp3196.etype;
        _size192 = _rtmp3196.size;
        for (let _i197 = 0; _i197 < _size192; ++_i197) {
          let elem198 = null;
          elem198 = input.readString();
          this.devices.push(elem198);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.reqId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetCtrlNeighborsResp.prototype.write = function(output) {
  output.writeStructBegin('GetCtrlNeighborsResp');
  if (this.devices !== null && this.devices !== undefined) {
    output.writeFieldBegin('devices', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.devices.length);
    for (let iter199 in this.devices) {
      if (this.devices.hasOwnProperty(iter199)) {
        iter199 = this.devices[iter199];
        output.writeString(iter199);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.reqId !== null && this.reqId !== undefined) {
    output.writeFieldBegin('reqId', Thrift.Type.STRING, 2);
    output.writeString(this.reqId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetNeighborsResp = module.exports.GetNeighborsResp = function(args) {
  this.deviceNeighborsMap = null;
  this.reqId = null;
  this.minion = null;
  if (args) {
    if (args.deviceNeighborsMap !== undefined && args.deviceNeighborsMap !== null) {
      this.deviceNeighborsMap = Thrift.copyMap(args.deviceNeighborsMap, [Thrift.copyList, null]);
    }
    if (args.reqId !== undefined && args.reqId !== null) {
      this.reqId = args.reqId;
    }
    if (args.minion !== undefined && args.minion !== null) {
      this.minion = args.minion;
    }
  }
};
GetNeighborsResp.prototype = {};
GetNeighborsResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size200 = 0;
        var _rtmp3204;
        this.deviceNeighborsMap = {};
        let _ktype201 = 0;
        let _vtype202 = 0;
        _rtmp3204 = input.readMapBegin();
        _ktype201 = _rtmp3204.ktype;
        _vtype202 = _rtmp3204.vtype;
        _size200 = _rtmp3204.size;
        for (let _i205 = 0; _i205 < _size200; ++_i205) {
          let key206 = null;
          let val207 = null;
          key206 = input.readString();
          let _size208 = 0;
          var _rtmp3212;
          val207 = [];
          let _etype211 = 0;
          _rtmp3212 = input.readListBegin();
          _etype211 = _rtmp3212.etype;
          _size208 = _rtmp3212.size;
          for (let _i213 = 0; _i213 < _size208; ++_i213) {
            let elem214 = null;
            elem214 = new ttypes.MinionNeighbor();
            elem214.read(input);
            val207.push(elem214);
          }
          input.readListEnd();
          this.deviceNeighborsMap[key206] = val207;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.reqId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.minion = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetNeighborsResp.prototype.write = function(output) {
  output.writeStructBegin('GetNeighborsResp');
  if (this.deviceNeighborsMap !== null && this.deviceNeighborsMap !== undefined) {
    output.writeFieldBegin('deviceNeighborsMap', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.deviceNeighborsMap));
    for (const kiter215 in this.deviceNeighborsMap) {
      if (this.deviceNeighborsMap.hasOwnProperty(kiter215)) {
        const viter216 = this.deviceNeighborsMap[kiter215];
        output.writeString(kiter215);
        output.writeListBegin(Thrift.Type.STRUCT, viter216.length);
        for (let iter217 in viter216) {
          if (viter216.hasOwnProperty(iter217)) {
            iter217 = viter216[iter217];
            iter217.write(output);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.reqId !== null && this.reqId !== undefined) {
    output.writeFieldBegin('reqId', Thrift.Type.STRING, 2);
    output.writeString(this.reqId);
    output.writeFieldEnd();
  }
  if (this.minion !== null && this.minion !== undefined) {
    output.writeFieldBegin('minion', Thrift.Type.STRING, 4);
    output.writeString(this.minion);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const MinionNeighbor = module.exports.MinionNeighbor = function(args) {
  this.ipv6Address = null;
  this.macAddr = null;
  this.state = null;
  if (args) {
    if (args.ipv6Address !== undefined && args.ipv6Address !== null) {
      this.ipv6Address = args.ipv6Address;
    }
    if (args.macAddr !== undefined && args.macAddr !== null) {
      this.macAddr = args.macAddr;
    }
    if (args.state !== undefined && args.state !== null) {
      this.state = args.state;
    }
  }
};
MinionNeighbor.prototype = {};
MinionNeighbor.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.ipv6Address = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.macAddr = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.state = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

MinionNeighbor.prototype.write = function(output) {
  output.writeStructBegin('MinionNeighbor');
  if (this.ipv6Address !== null && this.ipv6Address !== undefined) {
    output.writeFieldBegin('ipv6Address', Thrift.Type.STRING, 1);
    output.writeString(this.ipv6Address);
    output.writeFieldEnd();
  }
  if (this.macAddr !== null && this.macAddr !== undefined) {
    output.writeFieldBegin('macAddr', Thrift.Type.STRING, 2);
    output.writeString(this.macAddr);
    output.writeFieldEnd();
  }
  if (this.state !== null && this.state !== undefined) {
    output.writeFieldBegin('state', Thrift.Type.I32, 3);
    output.writeI32(this.state);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetMinionNeighborsReq = module.exports.GetMinionNeighborsReq = function(args) {
  this.devices = null;
  this.reqId = null;
  this.senderApp = null;
  if (args) {
    if (args.devices !== undefined && args.devices !== null) {
      this.devices = Thrift.copyList(args.devices, [null]);
    }
    if (args.reqId !== undefined && args.reqId !== null) {
      this.reqId = args.reqId;
    }
    if (args.senderApp !== undefined && args.senderApp !== null) {
      this.senderApp = args.senderApp;
    }
  }
};
GetMinionNeighborsReq.prototype = {};
GetMinionNeighborsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size218 = 0;
        var _rtmp3222;
        this.devices = [];
        let _etype221 = 0;
        _rtmp3222 = input.readListBegin();
        _etype221 = _rtmp3222.etype;
        _size218 = _rtmp3222.size;
        for (let _i223 = 0; _i223 < _size218; ++_i223) {
          let elem224 = null;
          elem224 = input.readString();
          this.devices.push(elem224);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.reqId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.senderApp = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetMinionNeighborsReq.prototype.write = function(output) {
  output.writeStructBegin('GetMinionNeighborsReq');
  if (this.devices !== null && this.devices !== undefined) {
    output.writeFieldBegin('devices', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.devices.length);
    for (let iter225 in this.devices) {
      if (this.devices.hasOwnProperty(iter225)) {
        iter225 = this.devices[iter225];
        output.writeString(iter225);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.reqId !== null && this.reqId !== undefined) {
    output.writeFieldBegin('reqId', Thrift.Type.STRING, 2);
    output.writeString(this.reqId);
    output.writeFieldEnd();
  }
  if (this.senderApp !== null && this.senderApp !== undefined) {
    output.writeFieldBegin('senderApp', Thrift.Type.STRING, 3);
    output.writeString(this.senderApp);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetMinionNeighborsResp = module.exports.GetMinionNeighborsResp = function(args) {
  this.deviceNeighborsMap = null;
  this.reqId = null;
  this.senderApp = null;
  if (args) {
    if (args.deviceNeighborsMap !== undefined && args.deviceNeighborsMap !== null) {
      this.deviceNeighborsMap = Thrift.copyMap(args.deviceNeighborsMap, [Thrift.copyList, ttypes.MinionNeighbor]);
    }
    if (args.reqId !== undefined && args.reqId !== null) {
      this.reqId = args.reqId;
    }
    if (args.senderApp !== undefined && args.senderApp !== null) {
      this.senderApp = args.senderApp;
    }
  }
};
GetMinionNeighborsResp.prototype = {};
GetMinionNeighborsResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size226 = 0;
        var _rtmp3230;
        this.deviceNeighborsMap = {};
        let _ktype227 = 0;
        let _vtype228 = 0;
        _rtmp3230 = input.readMapBegin();
        _ktype227 = _rtmp3230.ktype;
        _vtype228 = _rtmp3230.vtype;
        _size226 = _rtmp3230.size;
        for (let _i231 = 0; _i231 < _size226; ++_i231) {
          let key232 = null;
          let val233 = null;
          key232 = input.readString();
          let _size234 = 0;
          var _rtmp3238;
          val233 = [];
          let _etype237 = 0;
          _rtmp3238 = input.readListBegin();
          _etype237 = _rtmp3238.etype;
          _size234 = _rtmp3238.size;
          for (let _i239 = 0; _i239 < _size234; ++_i239) {
            let elem240 = null;
            elem240 = new ttypes.MinionNeighbor();
            elem240.read(input);
            val233.push(elem240);
          }
          input.readListEnd();
          this.deviceNeighborsMap[key232] = val233;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.reqId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.senderApp = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetMinionNeighborsResp.prototype.write = function(output) {
  output.writeStructBegin('GetMinionNeighborsResp');
  if (this.deviceNeighborsMap !== null && this.deviceNeighborsMap !== undefined) {
    output.writeFieldBegin('deviceNeighborsMap', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.deviceNeighborsMap));
    for (const kiter241 in this.deviceNeighborsMap) {
      if (this.deviceNeighborsMap.hasOwnProperty(kiter241)) {
        const viter242 = this.deviceNeighborsMap[kiter241];
        output.writeString(kiter241);
        output.writeListBegin(Thrift.Type.STRUCT, viter242.length);
        for (let iter243 in viter242) {
          if (viter242.hasOwnProperty(iter243)) {
            iter243 = viter242[iter243];
            iter243.write(output);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.reqId !== null && this.reqId !== undefined) {
    output.writeFieldBegin('reqId', Thrift.Type.STRING, 2);
    output.writeString(this.reqId);
    output.writeFieldEnd();
  }
  if (this.senderApp !== null && this.senderApp !== undefined) {
    output.writeFieldBegin('senderApp', Thrift.Type.STRING, 3);
    output.writeString(this.senderApp);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetIgnitionState = module.exports.GetIgnitionState = function(args) {
};
GetIgnitionState.prototype = {};
GetIgnitionState.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetIgnitionState.prototype.write = function(output) {
  output.writeStructBegin('GetIgnitionState');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const IgnitionParams = module.exports.IgnitionParams = function(args) {
  this.enable = null;
  this.linkUpInterval = null;
  this.linkUpDampenInterval = null;
  this.linkAutoIgnite = null;
  if (args) {
    if (args.enable !== undefined && args.enable !== null) {
      this.enable = args.enable;
    }
    if (args.linkUpInterval !== undefined && args.linkUpInterval !== null) {
      this.linkUpInterval = args.linkUpInterval;
    }
    if (args.linkUpDampenInterval !== undefined && args.linkUpDampenInterval !== null) {
      this.linkUpDampenInterval = args.linkUpDampenInterval;
    }
    if (args.linkAutoIgnite !== undefined && args.linkAutoIgnite !== null) {
      this.linkAutoIgnite = Thrift.copyMap(args.linkAutoIgnite, [null]);
    }
  }
};
IgnitionParams.prototype = {};
IgnitionParams.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.enable = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.linkUpInterval = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.linkUpDampenInterval = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.MAP) {
        let _size244 = 0;
        var _rtmp3248;
        this.linkAutoIgnite = {};
        let _ktype245 = 0;
        let _vtype246 = 0;
        _rtmp3248 = input.readMapBegin();
        _ktype245 = _rtmp3248.ktype;
        _vtype246 = _rtmp3248.vtype;
        _size244 = _rtmp3248.size;
        for (let _i249 = 0; _i249 < _size244; ++_i249) {
          let key250 = null;
          let val251 = null;
          key250 = input.readString();
          val251 = input.readBool();
          this.linkAutoIgnite[key250] = val251;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IgnitionParams.prototype.write = function(output) {
  output.writeStructBegin('IgnitionParams');
  if (this.enable !== null && this.enable !== undefined) {
    output.writeFieldBegin('enable', Thrift.Type.BOOL, 1);
    output.writeBool(this.enable);
    output.writeFieldEnd();
  }
  if (this.linkUpInterval !== null && this.linkUpInterval !== undefined) {
    output.writeFieldBegin('linkUpInterval', Thrift.Type.I64, 2);
    output.writeI64(this.linkUpInterval);
    output.writeFieldEnd();
  }
  if (this.linkUpDampenInterval !== null && this.linkUpDampenInterval !== undefined) {
    output.writeFieldBegin('linkUpDampenInterval', Thrift.Type.I64, 3);
    output.writeI64(this.linkUpDampenInterval);
    output.writeFieldEnd();
  }
  if (this.linkAutoIgnite !== null && this.linkAutoIgnite !== undefined) {
    output.writeFieldBegin('linkAutoIgnite', Thrift.Type.MAP, 4);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.BOOL, Thrift.objectLength(this.linkAutoIgnite));
    for (const kiter252 in this.linkAutoIgnite) {
      if (this.linkAutoIgnite.hasOwnProperty(kiter252)) {
        const viter253 = this.linkAutoIgnite[kiter252];
        output.writeString(kiter252);
        output.writeBool(viter253);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetLinkStatusReq = module.exports.SetLinkStatusReq = function(args) {
  this.action = null;
  this.initiatorNodeName = null;
  this.responderNodeName = null;
  if (args) {
    if (args.action !== undefined && args.action !== null) {
      this.action = args.action;
    }
    if (args.initiatorNodeName !== undefined && args.initiatorNodeName !== null) {
      this.initiatorNodeName = args.initiatorNodeName;
    }
    if (args.responderNodeName !== undefined && args.responderNodeName !== null) {
      this.responderNodeName = args.responderNodeName;
    }
  }
};
SetLinkStatusReq.prototype = {};
SetLinkStatusReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.action = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.initiatorNodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.responderNodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetLinkStatusReq.prototype.write = function(output) {
  output.writeStructBegin('SetLinkStatusReq');
  if (this.action !== null && this.action !== undefined) {
    output.writeFieldBegin('action', Thrift.Type.I32, 1);
    output.writeI32(this.action);
    output.writeFieldEnd();
  }
  if (this.initiatorNodeName !== null && this.initiatorNodeName !== undefined) {
    output.writeFieldBegin('initiatorNodeName', Thrift.Type.STRING, 2);
    output.writeString(this.initiatorNodeName);
    output.writeFieldEnd();
  }
  if (this.responderNodeName !== null && this.responderNodeName !== undefined) {
    output.writeFieldBegin('responderNodeName', Thrift.Type.STRING, 3);
    output.writeString(this.responderNodeName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const IgnitionCandidate = module.exports.IgnitionCandidate = function(args) {
  this.initiatorNodeName = null;
  this.linkName = null;
  if (args) {
    if (args.initiatorNodeName !== undefined && args.initiatorNodeName !== null) {
      this.initiatorNodeName = args.initiatorNodeName;
    }
    if (args.linkName !== undefined && args.linkName !== null) {
      this.linkName = args.linkName;
    }
  }
};
IgnitionCandidate.prototype = {};
IgnitionCandidate.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.initiatorNodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.linkName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IgnitionCandidate.prototype.write = function(output) {
  output.writeStructBegin('IgnitionCandidate');
  if (this.initiatorNodeName !== null && this.initiatorNodeName !== undefined) {
    output.writeFieldBegin('initiatorNodeName', Thrift.Type.STRING, 1);
    output.writeString(this.initiatorNodeName);
    output.writeFieldEnd();
  }
  if (this.linkName !== null && this.linkName !== undefined) {
    output.writeFieldBegin('linkName', Thrift.Type.STRING, 2);
    output.writeString(this.linkName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const IgnitionState = module.exports.IgnitionState = function(args) {
  this.visitedNodeNames = null;
  this.igCandidates = null;
  this.lastIgCandidates = null;
  this.igParams = null;
  if (args) {
    if (args.visitedNodeNames !== undefined && args.visitedNodeNames !== null) {
      this.visitedNodeNames = Thrift.copyList(args.visitedNodeNames, [null]);
    }
    if (args.igCandidates !== undefined && args.igCandidates !== null) {
      this.igCandidates = Thrift.copyList(args.igCandidates, [ttypes.IgnitionCandidate]);
    }
    if (args.lastIgCandidates !== undefined && args.lastIgCandidates !== null) {
      this.lastIgCandidates = Thrift.copyList(args.lastIgCandidates, [ttypes.IgnitionCandidate]);
    }
    if (args.igParams !== undefined && args.igParams !== null) {
      this.igParams = new ttypes.IgnitionParams(args.igParams);
    }
  }
};
IgnitionState.prototype = {};
IgnitionState.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size254 = 0;
        var _rtmp3258;
        this.visitedNodeNames = [];
        let _etype257 = 0;
        _rtmp3258 = input.readListBegin();
        _etype257 = _rtmp3258.etype;
        _size254 = _rtmp3258.size;
        for (let _i259 = 0; _i259 < _size254; ++_i259) {
          let elem260 = null;
          elem260 = input.readString();
          this.visitedNodeNames.push(elem260);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size261 = 0;
        var _rtmp3265;
        this.igCandidates = [];
        let _etype264 = 0;
        _rtmp3265 = input.readListBegin();
        _etype264 = _rtmp3265.etype;
        _size261 = _rtmp3265.size;
        for (let _i266 = 0; _i266 < _size261; ++_i266) {
          let elem267 = null;
          elem267 = new ttypes.IgnitionCandidate();
          elem267.read(input);
          this.igCandidates.push(elem267);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        let _size268 = 0;
        var _rtmp3272;
        this.lastIgCandidates = [];
        let _etype271 = 0;
        _rtmp3272 = input.readListBegin();
        _etype271 = _rtmp3272.etype;
        _size268 = _rtmp3272.size;
        for (let _i273 = 0; _i273 < _size268; ++_i273) {
          let elem274 = null;
          elem274 = new ttypes.IgnitionCandidate();
          elem274.read(input);
          this.lastIgCandidates.push(elem274);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.igParams = new ttypes.IgnitionParams();
        this.igParams.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IgnitionState.prototype.write = function(output) {
  output.writeStructBegin('IgnitionState');
  if (this.visitedNodeNames !== null && this.visitedNodeNames !== undefined) {
    output.writeFieldBegin('visitedNodeNames', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.visitedNodeNames.length);
    for (let iter275 in this.visitedNodeNames) {
      if (this.visitedNodeNames.hasOwnProperty(iter275)) {
        iter275 = this.visitedNodeNames[iter275];
        output.writeString(iter275);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.igCandidates !== null && this.igCandidates !== undefined) {
    output.writeFieldBegin('igCandidates', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.igCandidates.length);
    for (let iter276 in this.igCandidates) {
      if (this.igCandidates.hasOwnProperty(iter276)) {
        iter276 = this.igCandidates[iter276];
        iter276.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.lastIgCandidates !== null && this.lastIgCandidates !== undefined) {
    output.writeFieldBegin('lastIgCandidates', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.lastIgCandidates.length);
    for (let iter277 in this.lastIgCandidates) {
      if (this.lastIgCandidates.hasOwnProperty(iter277)) {
        iter277 = this.lastIgCandidates[iter277];
        iter277.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.igParams !== null && this.igParams !== undefined) {
    output.writeFieldBegin('igParams', Thrift.Type.STRUCT, 4);
    this.igParams.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetLinkStatus = module.exports.SetLinkStatus = function(args) {
  this.linkStatusType = null;
  this.responderMac = null;
  this.responderNodeType = null;
  this.golayIdx = null;
  this.controlSuperframe = null;
  this.responderNodePolarity = null;
  if (args) {
    if (args.linkStatusType !== undefined && args.linkStatusType !== null) {
      this.linkStatusType = args.linkStatusType;
    }
    if (args.responderMac !== undefined && args.responderMac !== null) {
      this.responderMac = args.responderMac;
    }
    if (args.responderNodeType !== undefined && args.responderNodeType !== null) {
      this.responderNodeType = args.responderNodeType;
    }
    if (args.golayIdx !== undefined && args.golayIdx !== null) {
      this.golayIdx = new Topology_ttypes.GolayIdx(args.golayIdx);
    }
    if (args.controlSuperframe !== undefined && args.controlSuperframe !== null) {
      this.controlSuperframe = args.controlSuperframe;
    }
    if (args.responderNodePolarity !== undefined && args.responderNodePolarity !== null) {
      this.responderNodePolarity = args.responderNodePolarity;
    }
  }
};
SetLinkStatus.prototype = {};
SetLinkStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.linkStatusType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.responderMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.responderNodeType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.golayIdx = new Topology_ttypes.GolayIdx();
        this.golayIdx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.controlSuperframe = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.responderNodePolarity = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetLinkStatus.prototype.write = function(output) {
  output.writeStructBegin('SetLinkStatus');
  if (this.linkStatusType !== null && this.linkStatusType !== undefined) {
    output.writeFieldBegin('linkStatusType', Thrift.Type.I32, 1);
    output.writeI32(this.linkStatusType);
    output.writeFieldEnd();
  }
  if (this.responderMac !== null && this.responderMac !== undefined) {
    output.writeFieldBegin('responderMac', Thrift.Type.STRING, 2);
    output.writeString(this.responderMac);
    output.writeFieldEnd();
  }
  if (this.responderNodeType !== null && this.responderNodeType !== undefined) {
    output.writeFieldBegin('responderNodeType', Thrift.Type.I32, 3);
    output.writeI32(this.responderNodeType);
    output.writeFieldEnd();
  }
  if (this.golayIdx !== null && this.golayIdx !== undefined) {
    output.writeFieldBegin('golayIdx', Thrift.Type.STRUCT, 4);
    this.golayIdx.write(output);
    output.writeFieldEnd();
  }
  if (this.controlSuperframe !== null && this.controlSuperframe !== undefined) {
    output.writeFieldBegin('controlSuperframe', Thrift.Type.I64, 5);
    output.writeI64(this.controlSuperframe);
    output.writeFieldEnd();
  }
  if (this.responderNodePolarity !== null && this.responderNodePolarity !== undefined) {
    output.writeFieldBegin('responderNodePolarity', Thrift.Type.I32, 6);
    output.writeI32(this.responderNodePolarity);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetLinkStatus = module.exports.GetLinkStatus = function(args) {
  this.responderMac = null;
  if (args) {
    if (args.responderMac !== undefined && args.responderMac !== null) {
      this.responderMac = args.responderMac;
    }
  }
};
GetLinkStatus.prototype = {};
GetLinkStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.responderMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetLinkStatus.prototype.write = function(output) {
  output.writeStructBegin('GetLinkStatus');
  if (this.responderMac !== null && this.responderMac !== undefined) {
    output.writeFieldBegin('responderMac', Thrift.Type.STRING, 1);
    output.writeString(this.responderMac);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const LinkStatus = module.exports.LinkStatus = function(args) {
  this.responderMac = null;
  this.linkStatusType = null;
  if (args) {
    if (args.responderMac !== undefined && args.responderMac !== null) {
      this.responderMac = args.responderMac;
    }
    if (args.linkStatusType !== undefined && args.linkStatusType !== null) {
      this.linkStatusType = args.linkStatusType;
    }
  }
};
LinkStatus.prototype = {};
LinkStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.responderMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.linkStatusType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

LinkStatus.prototype.write = function(output) {
  output.writeStructBegin('LinkStatus');
  if (this.responderMac !== null && this.responderMac !== undefined) {
    output.writeFieldBegin('responderMac', Thrift.Type.STRING, 1);
    output.writeString(this.responderMac);
    output.writeFieldEnd();
  }
  if (this.linkStatusType !== null && this.linkStatusType !== undefined) {
    output.writeFieldBegin('linkStatusType', Thrift.Type.I32, 2);
    output.writeI32(this.linkStatusType);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetTopology = module.exports.GetTopology = function(args) {
};
GetTopology.prototype = {};
GetTopology.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetTopology.prototype.write = function(output) {
  output.writeStructBegin('GetTopology');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetNetworkAirtime = module.exports.GetNetworkAirtime = function(args) {
};
GetNetworkAirtime.prototype = {};
GetNetworkAirtime.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetNetworkAirtime.prototype.write = function(output) {
  output.writeStructBegin('GetNetworkAirtime');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetNodeStatus = module.exports.SetNodeStatus = function(args) {
  this.nodeMac = null;
  this.markAllLinksDown = null;
  this.nodeStatus = null;
  if (args) {
    if (args.nodeMac !== undefined && args.nodeMac !== null) {
      this.nodeMac = args.nodeMac;
    }
    if (args.markAllLinksDown !== undefined && args.markAllLinksDown !== null) {
      this.markAllLinksDown = args.markAllLinksDown;
    }
    if (args.nodeStatus !== undefined && args.nodeStatus !== null) {
      this.nodeStatus = args.nodeStatus;
    }
  }
};
SetNodeStatus.prototype = {};
SetNodeStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.nodeMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.markAllLinksDown = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.nodeStatus = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetNodeStatus.prototype.write = function(output) {
  output.writeStructBegin('SetNodeStatus');
  if (this.nodeMac !== null && this.nodeMac !== undefined) {
    output.writeFieldBegin('nodeMac', Thrift.Type.STRING, 1);
    output.writeString(this.nodeMac);
    output.writeFieldEnd();
  }
  if (this.markAllLinksDown !== null && this.markAllLinksDown !== undefined) {
    output.writeFieldBegin('markAllLinksDown', Thrift.Type.BOOL, 2);
    output.writeBool(this.markAllLinksDown);
    output.writeFieldEnd();
  }
  if (this.nodeStatus !== null && this.nodeStatus !== undefined) {
    output.writeFieldBegin('nodeStatus', Thrift.Type.I32, 3);
    output.writeI32(this.nodeStatus);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetNodeParamsReq = module.exports.SetNodeParamsReq = function(args) {
  this.nodeMac = null;
  this.nodeAirtime = null;
  this.nodeBWAlloc = null;
  this.nodeIsPrimary = null;
  if (args) {
    if (args.nodeMac !== undefined && args.nodeMac !== null) {
      this.nodeMac = args.nodeMac;
    }
    if (args.nodeAirtime !== undefined && args.nodeAirtime !== null) {
      this.nodeAirtime = new BWAllocation_ttypes.NodeAirtime(args.nodeAirtime);
    }
    if (args.nodeBWAlloc !== undefined && args.nodeBWAlloc !== null) {
      this.nodeBWAlloc = new BWAllocation_ttypes.NodeBwAlloc(args.nodeBWAlloc);
    }
    if (args.nodeIsPrimary !== undefined && args.nodeIsPrimary !== null) {
      this.nodeIsPrimary = args.nodeIsPrimary;
    }
  }
};
SetNodeParamsReq.prototype = {};
SetNodeParamsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.nodeMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.nodeAirtime = new BWAllocation_ttypes.NodeAirtime();
        this.nodeAirtime.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.nodeBWAlloc = new BWAllocation_ttypes.NodeBwAlloc();
        this.nodeBWAlloc.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.BOOL) {
        this.nodeIsPrimary = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetNodeParamsReq.prototype.write = function(output) {
  output.writeStructBegin('SetNodeParamsReq');
  if (this.nodeMac !== null && this.nodeMac !== undefined) {
    output.writeFieldBegin('nodeMac', Thrift.Type.STRING, 1);
    output.writeString(this.nodeMac);
    output.writeFieldEnd();
  }
  if (this.nodeAirtime !== null && this.nodeAirtime !== undefined) {
    output.writeFieldBegin('nodeAirtime', Thrift.Type.STRUCT, 2);
    this.nodeAirtime.write(output);
    output.writeFieldEnd();
  }
  if (this.nodeBWAlloc !== null && this.nodeBWAlloc !== undefined) {
    output.writeFieldBegin('nodeBWAlloc', Thrift.Type.STRUCT, 3);
    this.nodeBWAlloc.write(output);
    output.writeFieldEnd();
  }
  if (this.nodeIsPrimary !== null && this.nodeIsPrimary !== undefined) {
    output.writeFieldBegin('nodeIsPrimary', Thrift.Type.BOOL, 4);
    output.writeBool(this.nodeIsPrimary);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetNetworkParamsReq = module.exports.SetNetworkParamsReq = function(args) {
  this.networkAirtime = null;
  this.networkBWAlloc = null;
  this.channel = null;
  if (args) {
    if (args.networkAirtime !== undefined && args.networkAirtime !== null) {
      this.networkAirtime = new BWAllocation_ttypes.NetworkAirtime(args.networkAirtime);
    }
    if (args.networkBWAlloc !== undefined && args.networkBWAlloc !== null) {
      this.networkBWAlloc = new BWAllocation_ttypes.NetworkBwAlloc(args.networkBWAlloc);
    }
    if (args.channel !== undefined && args.channel !== null) {
      this.channel = args.channel;
    }
  }
};
SetNetworkParamsReq.prototype = {};
SetNetworkParamsReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.networkAirtime = new BWAllocation_ttypes.NetworkAirtime();
        this.networkAirtime.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.networkBWAlloc = new BWAllocation_ttypes.NetworkBwAlloc();
        this.networkBWAlloc.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BYTE) {
        this.channel = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetNetworkParamsReq.prototype.write = function(output) {
  output.writeStructBegin('SetNetworkParamsReq');
  if (this.networkAirtime !== null && this.networkAirtime !== undefined) {
    output.writeFieldBegin('networkAirtime', Thrift.Type.STRUCT, 1);
    this.networkAirtime.write(output);
    output.writeFieldEnd();
  }
  if (this.networkBWAlloc !== null && this.networkBWAlloc !== undefined) {
    output.writeFieldBegin('networkBWAlloc', Thrift.Type.STRUCT, 2);
    this.networkBWAlloc.write(output);
    output.writeFieldEnd();
  }
  if (this.channel !== null && this.channel !== undefined) {
    output.writeFieldBegin('channel', Thrift.Type.BYTE, 3);
    output.writeByte(this.channel);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetNodeMac = module.exports.SetNodeMac = function(args) {
  this.nodeName = null;
  this.nodeMac = null;
  this.force = null;
  if (args) {
    if (args.nodeName !== undefined && args.nodeName !== null) {
      this.nodeName = args.nodeName;
    }
    if (args.nodeMac !== undefined && args.nodeMac !== null) {
      this.nodeMac = args.nodeMac;
    }
    if (args.force !== undefined && args.force !== null) {
      this.force = args.force;
    }
  }
};
SetNodeMac.prototype = {};
SetNodeMac.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.nodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.nodeMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.force = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetNodeMac.prototype.write = function(output) {
  output.writeStructBegin('SetNodeMac');
  if (this.nodeName !== null && this.nodeName !== undefined) {
    output.writeFieldBegin('nodeName', Thrift.Type.STRING, 1);
    output.writeString(this.nodeName);
    output.writeFieldEnd();
  }
  if (this.nodeMac !== null && this.nodeMac !== undefined) {
    output.writeFieldBegin('nodeMac', Thrift.Type.STRING, 2);
    output.writeString(this.nodeMac);
    output.writeFieldEnd();
  }
  if (this.force !== null && this.force !== undefined) {
    output.writeFieldBegin('force', Thrift.Type.BOOL, 3);
    output.writeBool(this.force);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetNodeMacList = module.exports.SetNodeMacList = function(args) {
  this.setNodeMacList = null;
  if (args) {
    if (args.setNodeMacList !== undefined && args.setNodeMacList !== null) {
      this.setNodeMacList = Thrift.copyList(args.setNodeMacList, [ttypes.SetNodeMac]);
    }
  }
};
SetNodeMacList.prototype = {};
SetNodeMacList.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size278 = 0;
        var _rtmp3282;
        this.setNodeMacList = [];
        let _etype281 = 0;
        _rtmp3282 = input.readListBegin();
        _etype281 = _rtmp3282.etype;
        _size278 = _rtmp3282.size;
        for (let _i283 = 0; _i283 < _size278; ++_i283) {
          let elem284 = null;
          elem284 = new ttypes.SetNodeMac();
          elem284.read(input);
          this.setNodeMacList.push(elem284);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetNodeMacList.prototype.write = function(output) {
  output.writeStructBegin('SetNodeMacList');
  if (this.setNodeMacList !== null && this.setNodeMacList !== undefined) {
    output.writeFieldBegin('setNodeMacList', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.setNodeMacList.length);
    for (let iter285 in this.setNodeMacList) {
      if (this.setNodeMacList.hasOwnProperty(iter285)) {
        iter285 = this.setNodeMacList[iter285];
        iter285.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetTopologyName = module.exports.SetTopologyName = function(args) {
  this.name = null;
  if (args) {
    if (args.name !== undefined && args.name !== null) {
      this.name = args.name;
    }
  }
};
SetTopologyName.prototype = {};
SetTopologyName.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetTopologyName.prototype.write = function(output) {
  output.writeStructBegin('SetTopologyName');
  if (this.name !== null && this.name !== undefined) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1);
    output.writeString(this.name);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BumpLinkUpAttempts = module.exports.BumpLinkUpAttempts = function(args) {
  this.linkName = null;
  if (args) {
    if (args.linkName !== undefined && args.linkName !== null) {
      this.linkName = args.linkName;
    }
  }
};
BumpLinkUpAttempts.prototype = {};
BumpLinkUpAttempts.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.linkName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BumpLinkUpAttempts.prototype.write = function(output) {
  output.writeStructBegin('BumpLinkUpAttempts');
  if (this.linkName !== null && this.linkName !== undefined) {
    output.writeFieldBegin('linkName', Thrift.Type.STRING, 1);
    output.writeString(this.linkName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const AddNode = module.exports.AddNode = function(args) {
  this.node = null;
  if (args) {
    if (args.node !== undefined && args.node !== null) {
      this.node = new Topology_ttypes.Node(args.node);
    }
  }
};
AddNode.prototype = {};
AddNode.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.node = new Topology_ttypes.Node();
        this.node.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

AddNode.prototype.write = function(output) {
  output.writeStructBegin('AddNode');
  if (this.node !== null && this.node !== undefined) {
    output.writeFieldBegin('node', Thrift.Type.STRUCT, 1);
    this.node.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const DelNode = module.exports.DelNode = function(args) {
  this.nodeName = null;
  this.force = null;
  if (args) {
    if (args.nodeName !== undefined && args.nodeName !== null) {
      this.nodeName = args.nodeName;
    }
    if (args.force !== undefined && args.force !== null) {
      this.force = args.force;
    }
  }
};
DelNode.prototype = {};
DelNode.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.nodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.force = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DelNode.prototype.write = function(output) {
  output.writeStructBegin('DelNode');
  if (this.nodeName !== null && this.nodeName !== undefined) {
    output.writeFieldBegin('nodeName', Thrift.Type.STRING, 1);
    output.writeString(this.nodeName);
    output.writeFieldEnd();
  }
  if (this.force !== null && this.force !== undefined) {
    output.writeFieldBegin('force', Thrift.Type.BOOL, 2);
    output.writeBool(this.force);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const EditNode = module.exports.EditNode = function(args) {
  this.nodeName = null;
  this.newNode = null;
  if (args) {
    if (args.nodeName !== undefined && args.nodeName !== null) {
      this.nodeName = args.nodeName;
    }
    if (args.newNode !== undefined && args.newNode !== null) {
      this.newNode = new Topology_ttypes.Node(args.newNode);
    }
  }
};
EditNode.prototype = {};
EditNode.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.nodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.newNode = new Topology_ttypes.Node();
        this.newNode.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

EditNode.prototype.write = function(output) {
  output.writeStructBegin('EditNode');
  if (this.nodeName !== null && this.nodeName !== undefined) {
    output.writeFieldBegin('nodeName', Thrift.Type.STRING, 1);
    output.writeString(this.nodeName);
    output.writeFieldEnd();
  }
  if (this.newNode !== null && this.newNode !== undefined) {
    output.writeFieldBegin('newNode', Thrift.Type.STRUCT, 2);
    this.newNode.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const AddLink = module.exports.AddLink = function(args) {
  this.link = null;
  if (args) {
    if (args.link !== undefined && args.link !== null) {
      this.link = new Topology_ttypes.Link(args.link);
    }
  }
};
AddLink.prototype = {};
AddLink.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.link = new Topology_ttypes.Link();
        this.link.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

AddLink.prototype.write = function(output) {
  output.writeStructBegin('AddLink');
  if (this.link !== null && this.link !== undefined) {
    output.writeFieldBegin('link', Thrift.Type.STRUCT, 1);
    this.link.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const DelLink = module.exports.DelLink = function(args) {
  this.aNodeName = null;
  this.zNodeName = null;
  this.force = null;
  if (args) {
    if (args.aNodeName !== undefined && args.aNodeName !== null) {
      this.aNodeName = args.aNodeName;
    }
    if (args.zNodeName !== undefined && args.zNodeName !== null) {
      this.zNodeName = args.zNodeName;
    }
    if (args.force !== undefined && args.force !== null) {
      this.force = args.force;
    }
  }
};
DelLink.prototype = {};
DelLink.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.aNodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.zNodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.force = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DelLink.prototype.write = function(output) {
  output.writeStructBegin('DelLink');
  if (this.aNodeName !== null && this.aNodeName !== undefined) {
    output.writeFieldBegin('aNodeName', Thrift.Type.STRING, 1);
    output.writeString(this.aNodeName);
    output.writeFieldEnd();
  }
  if (this.zNodeName !== null && this.zNodeName !== undefined) {
    output.writeFieldBegin('zNodeName', Thrift.Type.STRING, 2);
    output.writeString(this.zNodeName);
    output.writeFieldEnd();
  }
  if (this.force !== null && this.force !== undefined) {
    output.writeFieldBegin('force', Thrift.Type.BOOL, 3);
    output.writeBool(this.force);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const AddSite = module.exports.AddSite = function(args) {
  this.site = null;
  if (args) {
    if (args.site !== undefined && args.site !== null) {
      this.site = new Topology_ttypes.Site(args.site);
    }
  }
};
AddSite.prototype = {};
AddSite.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.site = new Topology_ttypes.Site();
        this.site.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

AddSite.prototype.write = function(output) {
  output.writeStructBegin('AddSite');
  if (this.site !== null && this.site !== undefined) {
    output.writeFieldBegin('site', Thrift.Type.STRUCT, 1);
    this.site.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const DelSite = module.exports.DelSite = function(args) {
  this.siteName = null;
  if (args) {
    if (args.siteName !== undefined && args.siteName !== null) {
      this.siteName = args.siteName;
    }
  }
};
DelSite.prototype = {};
DelSite.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.siteName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

DelSite.prototype.write = function(output) {
  output.writeStructBegin('DelSite');
  if (this.siteName !== null && this.siteName !== undefined) {
    output.writeFieldBegin('siteName', Thrift.Type.STRING, 1);
    output.writeString(this.siteName);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const EditSite = module.exports.EditSite = function(args) {
  this.siteName = null;
  this.newSite = null;
  if (args) {
    if (args.siteName !== undefined && args.siteName !== null) {
      this.siteName = args.siteName;
    }
    if (args.newSite !== undefined && args.newSite !== null) {
      this.newSite = new Topology_ttypes.Site(args.newSite);
    }
  }
};
EditSite.prototype = {};
EditSite.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.siteName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.newSite = new Topology_ttypes.Site();
        this.newSite.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

EditSite.prototype.write = function(output) {
  output.writeStructBegin('EditSite');
  if (this.siteName !== null && this.siteName !== undefined) {
    output.writeFieldBegin('siteName', Thrift.Type.STRING, 1);
    output.writeString(this.siteName);
    output.writeFieldEnd();
  }
  if (this.newSite !== null && this.newSite !== undefined) {
    output.writeFieldBegin('newSite', Thrift.Type.STRUCT, 2);
    this.newSite.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ResetTopologyState = module.exports.ResetTopologyState = function(args) {
  this.resetLinkupAttempts = null;
  if (args) {
    if (args.resetLinkupAttempts !== undefined && args.resetLinkupAttempts !== null) {
      this.resetLinkupAttempts = args.resetLinkupAttempts;
    }
  }
};
ResetTopologyState.prototype = {};
ResetTopologyState.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.resetLinkupAttempts = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ResetTopologyState.prototype.write = function(output) {
  output.writeStructBegin('ResetTopologyState');
  if (this.resetLinkupAttempts !== null && this.resetLinkupAttempts !== undefined) {
    output.writeFieldBegin('resetLinkupAttempts', Thrift.Type.BOOL, 1);
    output.writeBool(this.resetLinkupAttempts);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BulkAdd = module.exports.BulkAdd = function(args) {
  this.sites = null;
  this.nodes = null;
  this.links = null;
  if (args) {
    if (args.sites !== undefined && args.sites !== null) {
      this.sites = Thrift.copyList(args.sites, [Topology_ttypes.Site]);
    }
    if (args.nodes !== undefined && args.nodes !== null) {
      this.nodes = Thrift.copyList(args.nodes, [Topology_ttypes.Node]);
    }
    if (args.links !== undefined && args.links !== null) {
      this.links = Thrift.copyList(args.links, [Topology_ttypes.Link]);
    }
  }
};
BulkAdd.prototype = {};
BulkAdd.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size286 = 0;
        var _rtmp3290;
        this.sites = [];
        let _etype289 = 0;
        _rtmp3290 = input.readListBegin();
        _etype289 = _rtmp3290.etype;
        _size286 = _rtmp3290.size;
        for (let _i291 = 0; _i291 < _size286; ++_i291) {
          let elem292 = null;
          elem292 = new Topology_ttypes.Site();
          elem292.read(input);
          this.sites.push(elem292);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size293 = 0;
        var _rtmp3297;
        this.nodes = [];
        let _etype296 = 0;
        _rtmp3297 = input.readListBegin();
        _etype296 = _rtmp3297.etype;
        _size293 = _rtmp3297.size;
        for (let _i298 = 0; _i298 < _size293; ++_i298) {
          let elem299 = null;
          elem299 = new Topology_ttypes.Node();
          elem299.read(input);
          this.nodes.push(elem299);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        let _size300 = 0;
        var _rtmp3304;
        this.links = [];
        let _etype303 = 0;
        _rtmp3304 = input.readListBegin();
        _etype303 = _rtmp3304.etype;
        _size300 = _rtmp3304.size;
        for (let _i305 = 0; _i305 < _size300; ++_i305) {
          let elem306 = null;
          elem306 = new Topology_ttypes.Link();
          elem306.read(input);
          this.links.push(elem306);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BulkAdd.prototype.write = function(output) {
  output.writeStructBegin('BulkAdd');
  if (this.sites !== null && this.sites !== undefined) {
    output.writeFieldBegin('sites', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.sites.length);
    for (let iter307 in this.sites) {
      if (this.sites.hasOwnProperty(iter307)) {
        iter307 = this.sites[iter307];
        iter307.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.nodes !== null && this.nodes !== undefined) {
    output.writeFieldBegin('nodes', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.nodes.length);
    for (let iter308 in this.nodes) {
      if (this.nodes.hasOwnProperty(iter308)) {
        iter308 = this.nodes[iter308];
        iter308.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.links !== null && this.links !== undefined) {
    output.writeFieldBegin('links', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.links.length);
    for (let iter309 in this.links) {
      if (this.links.hasOwnProperty(iter309)) {
        iter309 = this.links[iter309];
        iter309.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetRoutes = module.exports.GetRoutes = function(args) {
  this.srcNode = null;
  this.dstNode = null;
  if (args) {
    if (args.srcNode !== undefined && args.srcNode !== null) {
      this.srcNode = args.srcNode;
    }
    if (args.dstNode !== undefined && args.dstNode !== null) {
      this.dstNode = args.dstNode;
    }
  }
};
GetRoutes.prototype = {};
GetRoutes.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.srcNode = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.dstNode = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetRoutes.prototype.write = function(output) {
  output.writeStructBegin('GetRoutes');
  if (this.srcNode !== null && this.srcNode !== undefined) {
    output.writeFieldBegin('srcNode', Thrift.Type.STRING, 1);
    output.writeString(this.srcNode);
    output.writeFieldEnd();
  }
  if (this.dstNode !== null && this.dstNode !== undefined) {
    output.writeFieldBegin('dstNode', Thrift.Type.STRING, 2);
    output.writeString(this.dstNode);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetRoutesResp = module.exports.GetRoutesResp = function(args) {
  this.routes = null;
  if (args) {
    if (args.routes !== undefined && args.routes !== null) {
      this.routes = Thrift.copyList(args.routes, [Thrift.copyList, null]);
    }
  }
};
GetRoutesResp.prototype = {};
GetRoutesResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size310 = 0;
        var _rtmp3314;
        this.routes = [];
        let _etype313 = 0;
        _rtmp3314 = input.readListBegin();
        _etype313 = _rtmp3314.etype;
        _size310 = _rtmp3314.size;
        for (let _i315 = 0; _i315 < _size310; ++_i315) {
          let elem316 = null;
          let _size317 = 0;
          var _rtmp3321;
          elem316 = [];
          let _etype320 = 0;
          _rtmp3321 = input.readListBegin();
          _etype320 = _rtmp3321.etype;
          _size317 = _rtmp3321.size;
          for (let _i322 = 0; _i322 < _size317; ++_i322) {
            let elem323 = null;
            elem323 = input.readString();
            elem316.push(elem323);
          }
          input.readListEnd();
          this.routes.push(elem316);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetRoutesResp.prototype.write = function(output) {
  output.writeStructBegin('GetRoutesResp');
  if (this.routes !== null && this.routes !== undefined) {
    output.writeFieldBegin('routes', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.LIST, this.routes.length);
    for (let iter324 in this.routes) {
      if (this.routes.hasOwnProperty(iter324)) {
        iter324 = this.routes[iter324];
        output.writeListBegin(Thrift.Type.STRING, iter324.length);
        for (let iter325 in iter324) {
          if (iter324.hasOwnProperty(iter325)) {
            iter325 = iter324[iter325];
            output.writeString(iter325);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const MicroRoute = module.exports.MicroRoute = function(args) {
  this.tx = null;
  this.rx = null;
  if (args) {
    if (args.tx !== undefined && args.tx !== null) {
      this.tx = args.tx;
    }
    if (args.rx !== undefined && args.rx !== null) {
      this.rx = args.rx;
    }
  }
};
MicroRoute.prototype = {};
MicroRoute.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I16) {
        this.tx = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I16) {
        this.rx = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

MicroRoute.prototype.write = function(output) {
  output.writeStructBegin('MicroRoute');
  if (this.tx !== null && this.tx !== undefined) {
    output.writeFieldBegin('tx', Thrift.Type.I16, 1);
    output.writeI16(this.tx);
    output.writeFieldEnd();
  }
  if (this.rx !== null && this.rx !== undefined) {
    output.writeFieldBegin('rx', Thrift.Type.I16, 2);
    output.writeI16(this.rx);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const RouteInfo = module.exports.RouteInfo = function(args) {
  this.route = null;
  this.rssi = null;
  this.snrEst = null;
  this.postSnr = null;
  this.rxStart = null;
  this.packetIdx = null;
  this.sweepIdx = null;
  if (args) {
    if (args.route !== undefined && args.route !== null) {
      this.route = new ttypes.MicroRoute(args.route);
    }
    if (args.rssi !== undefined && args.rssi !== null) {
      this.rssi = args.rssi;
    }
    if (args.snrEst !== undefined && args.snrEst !== null) {
      this.snrEst = args.snrEst;
    }
    if (args.postSnr !== undefined && args.postSnr !== null) {
      this.postSnr = args.postSnr;
    }
    if (args.rxStart !== undefined && args.rxStart !== null) {
      this.rxStart = args.rxStart;
    }
    if (args.packetIdx !== undefined && args.packetIdx !== null) {
      this.packetIdx = args.packetIdx;
    }
    if (args.sweepIdx !== undefined && args.sweepIdx !== null) {
      this.sweepIdx = args.sweepIdx;
    }
  }
};
RouteInfo.prototype = {};
RouteInfo.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.route = new ttypes.MicroRoute();
        this.route.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.DOUBLE) {
        this.rssi = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.DOUBLE) {
        this.snrEst = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.DOUBLE) {
        this.postSnr = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.rxStart = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.BYTE) {
        this.packetIdx = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I16) {
        this.sweepIdx = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

RouteInfo.prototype.write = function(output) {
  output.writeStructBegin('RouteInfo');
  if (this.route !== null && this.route !== undefined) {
    output.writeFieldBegin('route', Thrift.Type.STRUCT, 1);
    this.route.write(output);
    output.writeFieldEnd();
  }
  if (this.rssi !== null && this.rssi !== undefined) {
    output.writeFieldBegin('rssi', Thrift.Type.DOUBLE, 2);
    output.writeDouble(this.rssi);
    output.writeFieldEnd();
  }
  if (this.snrEst !== null && this.snrEst !== undefined) {
    output.writeFieldBegin('snrEst', Thrift.Type.DOUBLE, 3);
    output.writeDouble(this.snrEst);
    output.writeFieldEnd();
  }
  if (this.postSnr !== null && this.postSnr !== undefined) {
    output.writeFieldBegin('postSnr', Thrift.Type.DOUBLE, 4);
    output.writeDouble(this.postSnr);
    output.writeFieldEnd();
  }
  if (this.rxStart !== null && this.rxStart !== undefined) {
    output.writeFieldBegin('rxStart', Thrift.Type.I32, 5);
    output.writeI32(this.rxStart);
    output.writeFieldEnd();
  }
  if (this.packetIdx !== null && this.packetIdx !== undefined) {
    output.writeFieldBegin('packetIdx', Thrift.Type.BYTE, 6);
    output.writeByte(this.packetIdx);
    output.writeFieldEnd();
  }
  if (this.sweepIdx !== null && this.sweepIdx !== undefined) {
    output.writeFieldBegin('sweepIdx', Thrift.Type.I16, 7);
    output.writeI16(this.sweepIdx);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BeamIndices = module.exports.BeamIndices = function(args) {
  this.low = null;
  this.high = null;
  if (args) {
    if (args.low !== undefined && args.low !== null) {
      this.low = args.low;
    }
    if (args.high !== undefined && args.high !== null) {
      this.high = args.high;
    }
  }
};
BeamIndices.prototype = {};
BeamIndices.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.low = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.high = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BeamIndices.prototype.write = function(output) {
  output.writeStructBegin('BeamIndices');
  if (this.low !== null && this.low !== undefined) {
    output.writeFieldBegin('low', Thrift.Type.I32, 1);
    output.writeI32(this.low);
    output.writeFieldEnd();
  }
  if (this.high !== null && this.high !== undefined) {
    output.writeFieldBegin('high', Thrift.Type.I32, 2);
    output.writeI32(this.high);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ScanReq = module.exports.ScanReq = function(args) {
  this.token = null;
  this.scanType = null;
  this.scanMode = null;
  this.startBwgdIdx = null;
  this.bfScanInvertPolarity = null;
  this.txNodeMac = null;
  this.rxNodeMac = null;
  this.routes = null;
  this.beams = null;
  this.apply = null;
  this.rtCalType = null;
  this.bwgdLen = null;
  this.txPwrIndex = null;
  this.nullAngle = null;
  this.cbfBeamIdx = null;
  this.isAggressor = null;
  if (args) {
    if (args.token !== undefined && args.token !== null) {
      this.token = args.token;
    }
    if (args.scanType !== undefined && args.scanType !== null) {
      this.scanType = args.scanType;
    }
    if (args.scanMode !== undefined && args.scanMode !== null) {
      this.scanMode = args.scanMode;
    }
    if (args.startBwgdIdx !== undefined && args.startBwgdIdx !== null) {
      this.startBwgdIdx = args.startBwgdIdx;
    }
    if (args.bfScanInvertPolarity !== undefined && args.bfScanInvertPolarity !== null) {
      this.bfScanInvertPolarity = args.bfScanInvertPolarity;
    }
    if (args.txNodeMac !== undefined && args.txNodeMac !== null) {
      this.txNodeMac = args.txNodeMac;
    }
    if (args.rxNodeMac !== undefined && args.rxNodeMac !== null) {
      this.rxNodeMac = args.rxNodeMac;
    }
    if (args.routes !== undefined && args.routes !== null) {
      this.routes = Thrift.copyList(args.routes, [ttypes.MicroRoute]);
    }
    if (args.beams !== undefined && args.beams !== null) {
      this.beams = new ttypes.BeamIndices(args.beams);
    }
    if (args.apply !== undefined && args.apply !== null) {
      this.apply = args.apply;
    }
    if (args.rtCalType !== undefined && args.rtCalType !== null) {
      this.rtCalType = args.rtCalType;
    }
    if (args.bwgdLen !== undefined && args.bwgdLen !== null) {
      this.bwgdLen = args.bwgdLen;
    }
    if (args.txPwrIndex !== undefined && args.txPwrIndex !== null) {
      this.txPwrIndex = args.txPwrIndex;
    }
    if (args.nullAngle !== undefined && args.nullAngle !== null) {
      this.nullAngle = args.nullAngle;
    }
    if (args.cbfBeamIdx !== undefined && args.cbfBeamIdx !== null) {
      this.cbfBeamIdx = args.cbfBeamIdx;
    }
    if (args.isAggressor !== undefined && args.isAggressor !== null) {
      this.isAggressor = args.isAggressor;
    }
  }
};
ScanReq.prototype = {};
ScanReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.token = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.I32) {
        this.scanType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.scanMode = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.startBwgdIdx = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.BOOL) {
        this.bfScanInvertPolarity = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.txNodeMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.rxNodeMac = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.LIST) {
        let _size326 = 0;
        var _rtmp3330;
        this.routes = [];
        let _etype329 = 0;
        _rtmp3330 = input.readListBegin();
        _etype329 = _rtmp3330.etype;
        _size326 = _rtmp3330.size;
        for (let _i331 = 0; _i331 < _size326; ++_i331) {
          let elem332 = null;
          elem332 = new ttypes.MicroRoute();
          elem332.read(input);
          this.routes.push(elem332);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.beams = new ttypes.BeamIndices();
        this.beams.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.BOOL) {
        this.apply = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I32) {
        this.rtCalType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.BYTE) {
        this.bwgdLen = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.I16) {
        this.txPwrIndex = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.I16) {
        this.nullAngle = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 15:
      if (ftype == Thrift.Type.I16) {
        this.cbfBeamIdx = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 16:
      if (ftype == Thrift.Type.BOOL) {
        this.isAggressor = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ScanReq.prototype.write = function(output) {
  output.writeStructBegin('ScanReq');
  if (this.token !== null && this.token !== undefined) {
    output.writeFieldBegin('token', Thrift.Type.I32, 1);
    output.writeI32(this.token);
    output.writeFieldEnd();
  }
  if (this.scanType !== null && this.scanType !== undefined) {
    output.writeFieldBegin('scanType', Thrift.Type.I32, 13);
    output.writeI32(this.scanType);
    output.writeFieldEnd();
  }
  if (this.scanMode !== null && this.scanMode !== undefined) {
    output.writeFieldBegin('scanMode', Thrift.Type.I32, 2);
    output.writeI32(this.scanMode);
    output.writeFieldEnd();
  }
  if (this.startBwgdIdx !== null && this.startBwgdIdx !== undefined) {
    output.writeFieldBegin('startBwgdIdx', Thrift.Type.I64, 3);
    output.writeI64(this.startBwgdIdx);
    output.writeFieldEnd();
  }
  if (this.bfScanInvertPolarity !== null && this.bfScanInvertPolarity !== undefined) {
    output.writeFieldBegin('bfScanInvertPolarity', Thrift.Type.BOOL, 4);
    output.writeBool(this.bfScanInvertPolarity);
    output.writeFieldEnd();
  }
  if (this.txNodeMac !== null && this.txNodeMac !== undefined) {
    output.writeFieldBegin('txNodeMac', Thrift.Type.STRING, 5);
    output.writeString(this.txNodeMac);
    output.writeFieldEnd();
  }
  if (this.rxNodeMac !== null && this.rxNodeMac !== undefined) {
    output.writeFieldBegin('rxNodeMac', Thrift.Type.STRING, 6);
    output.writeString(this.rxNodeMac);
    output.writeFieldEnd();
  }
  if (this.routes !== null && this.routes !== undefined) {
    output.writeFieldBegin('routes', Thrift.Type.LIST, 7);
    output.writeListBegin(Thrift.Type.STRUCT, this.routes.length);
    for (let iter333 in this.routes) {
      if (this.routes.hasOwnProperty(iter333)) {
        iter333 = this.routes[iter333];
        iter333.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.beams !== null && this.beams !== undefined) {
    output.writeFieldBegin('beams', Thrift.Type.STRUCT, 8);
    this.beams.write(output);
    output.writeFieldEnd();
  }
  if (this.apply !== null && this.apply !== undefined) {
    output.writeFieldBegin('apply', Thrift.Type.BOOL, 9);
    output.writeBool(this.apply);
    output.writeFieldEnd();
  }
  if (this.rtCalType !== null && this.rtCalType !== undefined) {
    output.writeFieldBegin('rtCalType', Thrift.Type.I32, 10);
    output.writeI32(this.rtCalType);
    output.writeFieldEnd();
  }
  if (this.bwgdLen !== null && this.bwgdLen !== undefined) {
    output.writeFieldBegin('bwgdLen', Thrift.Type.BYTE, 11);
    output.writeByte(this.bwgdLen);
    output.writeFieldEnd();
  }
  if (this.txPwrIndex !== null && this.txPwrIndex !== undefined) {
    output.writeFieldBegin('txPwrIndex', Thrift.Type.I16, 12);
    output.writeI16(this.txPwrIndex);
    output.writeFieldEnd();
  }
  if (this.nullAngle !== null && this.nullAngle !== undefined) {
    output.writeFieldBegin('nullAngle', Thrift.Type.I16, 14);
    output.writeI16(this.nullAngle);
    output.writeFieldEnd();
  }
  if (this.cbfBeamIdx !== null && this.cbfBeamIdx !== undefined) {
    output.writeFieldBegin('cbfBeamIdx', Thrift.Type.I16, 15);
    output.writeI16(this.cbfBeamIdx);
    output.writeFieldEnd();
  }
  if (this.isAggressor !== null && this.isAggressor !== undefined) {
    output.writeFieldBegin('isAggressor', Thrift.Type.BOOL, 16);
    output.writeBool(this.isAggressor);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ScanResp = module.exports.ScanResp = function(args) {
  this.token = null;
  this.curSuperframeNum = null;
  this.routeInfoList = null;
  this.txPwrIndex = null;
  this.status = null;
  this.role = null;
  this.numSweeps = null;
  this.startSuperframeNum = null;
  this.endSuperframeNum = null;
  this.azimuthBeam = null;
  this.oldBeam = null;
  this.newBeam = null;
  this.sweepStartBeam = null;
  this.sweepEndBeam = null;
  if (args) {
    if (args.token !== undefined && args.token !== null) {
      this.token = args.token;
    }
    if (args.curSuperframeNum !== undefined && args.curSuperframeNum !== null) {
      this.curSuperframeNum = args.curSuperframeNum;
    }
    if (args.routeInfoList !== undefined && args.routeInfoList !== null) {
      this.routeInfoList = Thrift.copyList(args.routeInfoList, [ttypes.RouteInfo]);
    }
    if (args.txPwrIndex !== undefined && args.txPwrIndex !== null) {
      this.txPwrIndex = args.txPwrIndex;
    }
    if (args.status !== undefined && args.status !== null) {
      this.status = args.status;
    }
    if (args.role !== undefined && args.role !== null) {
      this.role = args.role;
    }
    if (args.numSweeps !== undefined && args.numSweeps !== null) {
      this.numSweeps = args.numSweeps;
    }
    if (args.startSuperframeNum !== undefined && args.startSuperframeNum !== null) {
      this.startSuperframeNum = args.startSuperframeNum;
    }
    if (args.endSuperframeNum !== undefined && args.endSuperframeNum !== null) {
      this.endSuperframeNum = args.endSuperframeNum;
    }
    if (args.azimuthBeam !== undefined && args.azimuthBeam !== null) {
      this.azimuthBeam = args.azimuthBeam;
    }
    if (args.oldBeam !== undefined && args.oldBeam !== null) {
      this.oldBeam = args.oldBeam;
    }
    if (args.newBeam !== undefined && args.newBeam !== null) {
      this.newBeam = args.newBeam;
    }
    if (args.sweepStartBeam !== undefined && args.sweepStartBeam !== null) {
      this.sweepStartBeam = args.sweepStartBeam;
    }
    if (args.sweepEndBeam !== undefined && args.sweepEndBeam !== null) {
      this.sweepEndBeam = args.sweepEndBeam;
    }
  }
};
ScanResp.prototype = {};
ScanResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.token = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.curSuperframeNum = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        let _size334 = 0;
        var _rtmp3338;
        this.routeInfoList = [];
        let _etype337 = 0;
        _rtmp3338 = input.readListBegin();
        _etype337 = _rtmp3338.etype;
        _size334 = _rtmp3338.size;
        for (let _i339 = 0; _i339 < _size334; ++_i339) {
          let elem340 = null;
          elem340 = new ttypes.RouteInfo();
          elem340.read(input);
          this.routeInfoList.push(elem340);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I16) {
        this.txPwrIndex = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.status = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I16) {
        this.role = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I16) {
        this.numSweeps = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I64) {
        this.startSuperframeNum = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I64) {
        this.endSuperframeNum = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I16) {
        this.azimuthBeam = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.I16) {
        this.oldBeam = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.I16) {
        this.newBeam = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.I16) {
        this.sweepStartBeam = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.I16) {
        this.sweepEndBeam = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ScanResp.prototype.write = function(output) {
  output.writeStructBegin('ScanResp');
  if (this.token !== null && this.token !== undefined) {
    output.writeFieldBegin('token', Thrift.Type.I32, 1);
    output.writeI32(this.token);
    output.writeFieldEnd();
  }
  if (this.curSuperframeNum !== null && this.curSuperframeNum !== undefined) {
    output.writeFieldBegin('curSuperframeNum', Thrift.Type.I64, 2);
    output.writeI64(this.curSuperframeNum);
    output.writeFieldEnd();
  }
  if (this.routeInfoList !== null && this.routeInfoList !== undefined) {
    output.writeFieldBegin('routeInfoList', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.routeInfoList.length);
    for (let iter341 in this.routeInfoList) {
      if (this.routeInfoList.hasOwnProperty(iter341)) {
        iter341 = this.routeInfoList[iter341];
        iter341.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.txPwrIndex !== null && this.txPwrIndex !== undefined) {
    output.writeFieldBegin('txPwrIndex', Thrift.Type.I16, 4);
    output.writeI16(this.txPwrIndex);
    output.writeFieldEnd();
  }
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.I32, 5);
    output.writeI32(this.status);
    output.writeFieldEnd();
  }
  if (this.role !== null && this.role !== undefined) {
    output.writeFieldBegin('role', Thrift.Type.I16, 6);
    output.writeI16(this.role);
    output.writeFieldEnd();
  }
  if (this.numSweeps !== null && this.numSweeps !== undefined) {
    output.writeFieldBegin('numSweeps', Thrift.Type.I16, 7);
    output.writeI16(this.numSweeps);
    output.writeFieldEnd();
  }
  if (this.startSuperframeNum !== null && this.startSuperframeNum !== undefined) {
    output.writeFieldBegin('startSuperframeNum', Thrift.Type.I64, 8);
    output.writeI64(this.startSuperframeNum);
    output.writeFieldEnd();
  }
  if (this.endSuperframeNum !== null && this.endSuperframeNum !== undefined) {
    output.writeFieldBegin('endSuperframeNum', Thrift.Type.I64, 9);
    output.writeI64(this.endSuperframeNum);
    output.writeFieldEnd();
  }
  if (this.azimuthBeam !== null && this.azimuthBeam !== undefined) {
    output.writeFieldBegin('azimuthBeam', Thrift.Type.I16, 10);
    output.writeI16(this.azimuthBeam);
    output.writeFieldEnd();
  }
  if (this.oldBeam !== null && this.oldBeam !== undefined) {
    output.writeFieldBegin('oldBeam', Thrift.Type.I16, 11);
    output.writeI16(this.oldBeam);
    output.writeFieldEnd();
  }
  if (this.newBeam !== null && this.newBeam !== undefined) {
    output.writeFieldBegin('newBeam', Thrift.Type.I16, 12);
    output.writeI16(this.newBeam);
    output.writeFieldEnd();
  }
  if (this.sweepStartBeam !== null && this.sweepStartBeam !== undefined) {
    output.writeFieldBegin('sweepStartBeam', Thrift.Type.I16, 13);
    output.writeI16(this.sweepStartBeam);
    output.writeFieldEnd();
  }
  if (this.sweepEndBeam !== null && this.sweepEndBeam !== undefined) {
    output.writeFieldBegin('sweepEndBeam', Thrift.Type.I16, 14);
    output.writeI16(this.sweepEndBeam);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StartScan = module.exports.StartScan = function(args) {
  this.scanType = null;
  this.scanMode = null;
  this.startTime = null;
  this.txNode = null;
  this.rxNodes = null;
  this.beams = null;
  this.apply = null;
  this.rtCalType = null;
  this.bwgdLen = null;
  this.txPwrIndex = null;
  this.mainTxNode = null;
  this.mainRxNode = null;
  this.auxTxNodes = null;
  this.auxRxNodes = null;
  this.auxTxPwrIndex = null;
  this.nullAngle = null;
  this.cbfBeamIdx = null;
  if (args) {
    if (args.scanType !== undefined && args.scanType !== null) {
      this.scanType = args.scanType;
    }
    if (args.scanMode !== undefined && args.scanMode !== null) {
      this.scanMode = args.scanMode;
    }
    if (args.startTime !== undefined && args.startTime !== null) {
      this.startTime = args.startTime;
    }
    if (args.txNode !== undefined && args.txNode !== null) {
      this.txNode = args.txNode;
    }
    if (args.rxNodes !== undefined && args.rxNodes !== null) {
      this.rxNodes = Thrift.copyList(args.rxNodes, [null]);
    }
    if (args.beams !== undefined && args.beams !== null) {
      this.beams = Thrift.copyList(args.beams, [ttypes.BeamIndices]);
    }
    if (args.apply !== undefined && args.apply !== null) {
      this.apply = args.apply;
    }
    if (args.rtCalType !== undefined && args.rtCalType !== null) {
      this.rtCalType = args.rtCalType;
    }
    if (args.bwgdLen !== undefined && args.bwgdLen !== null) {
      this.bwgdLen = args.bwgdLen;
    }
    if (args.txPwrIndex !== undefined && args.txPwrIndex !== null) {
      this.txPwrIndex = args.txPwrIndex;
    }
    if (args.mainTxNode !== undefined && args.mainTxNode !== null) {
      this.mainTxNode = args.mainTxNode;
    }
    if (args.mainRxNode !== undefined && args.mainRxNode !== null) {
      this.mainRxNode = args.mainRxNode;
    }
    if (args.auxTxNodes !== undefined && args.auxTxNodes !== null) {
      this.auxTxNodes = Thrift.copyList(args.auxTxNodes, [null]);
    }
    if (args.auxRxNodes !== undefined && args.auxRxNodes !== null) {
      this.auxRxNodes = Thrift.copyList(args.auxRxNodes, [null]);
    }
    if (args.auxTxPwrIndex !== undefined && args.auxTxPwrIndex !== null) {
      this.auxTxPwrIndex = Thrift.copyList(args.auxTxPwrIndex, [null]);
    }
    if (args.nullAngle !== undefined && args.nullAngle !== null) {
      this.nullAngle = args.nullAngle;
    }
    if (args.cbfBeamIdx !== undefined && args.cbfBeamIdx !== null) {
      this.cbfBeamIdx = args.cbfBeamIdx;
    }
  }
};
StartScan.prototype = {};
StartScan.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.scanType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.scanMode = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.startTime = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.txNode = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.LIST) {
        let _size342 = 0;
        var _rtmp3346;
        this.rxNodes = [];
        let _etype345 = 0;
        _rtmp3346 = input.readListBegin();
        _etype345 = _rtmp3346.etype;
        _size342 = _rtmp3346.size;
        for (let _i347 = 0; _i347 < _size342; ++_i347) {
          let elem348 = null;
          elem348 = input.readString();
          this.rxNodes.push(elem348);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.LIST) {
        let _size349 = 0;
        var _rtmp3353;
        this.beams = [];
        let _etype352 = 0;
        _rtmp3353 = input.readListBegin();
        _etype352 = _rtmp3353.etype;
        _size349 = _rtmp3353.size;
        for (let _i354 = 0; _i354 < _size349; ++_i354) {
          let elem355 = null;
          elem355 = new ttypes.BeamIndices();
          elem355.read(input);
          this.beams.push(elem355);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.BOOL) {
        this.apply = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I32) {
        this.rtCalType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.BYTE) {
        this.bwgdLen = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I16) {
        this.txPwrIndex = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.STRING) {
        this.mainTxNode = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.STRING) {
        this.mainRxNode = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.LIST) {
        let _size356 = 0;
        var _rtmp3360;
        this.auxTxNodes = [];
        let _etype359 = 0;
        _rtmp3360 = input.readListBegin();
        _etype359 = _rtmp3360.etype;
        _size356 = _rtmp3360.size;
        for (let _i361 = 0; _i361 < _size356; ++_i361) {
          let elem362 = null;
          elem362 = input.readString();
          this.auxTxNodes.push(elem362);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.LIST) {
        let _size363 = 0;
        var _rtmp3367;
        this.auxRxNodes = [];
        let _etype366 = 0;
        _rtmp3367 = input.readListBegin();
        _etype366 = _rtmp3367.etype;
        _size363 = _rtmp3367.size;
        for (let _i368 = 0; _i368 < _size363; ++_i368) {
          let elem369 = null;
          elem369 = input.readString();
          this.auxRxNodes.push(elem369);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 15:
      if (ftype == Thrift.Type.LIST) {
        let _size370 = 0;
        var _rtmp3374;
        this.auxTxPwrIndex = [];
        let _etype373 = 0;
        _rtmp3374 = input.readListBegin();
        _etype373 = _rtmp3374.etype;
        _size370 = _rtmp3374.size;
        for (let _i375 = 0; _i375 < _size370; ++_i375) {
          let elem376 = null;
          elem376 = input.readI16();
          this.auxTxPwrIndex.push(elem376);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 16:
      if (ftype == Thrift.Type.I16) {
        this.nullAngle = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 17:
      if (ftype == Thrift.Type.I16) {
        this.cbfBeamIdx = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StartScan.prototype.write = function(output) {
  output.writeStructBegin('StartScan');
  if (this.scanType !== null && this.scanType !== undefined) {
    output.writeFieldBegin('scanType', Thrift.Type.I32, 1);
    output.writeI32(this.scanType);
    output.writeFieldEnd();
  }
  if (this.scanMode !== null && this.scanMode !== undefined) {
    output.writeFieldBegin('scanMode', Thrift.Type.I32, 2);
    output.writeI32(this.scanMode);
    output.writeFieldEnd();
  }
  if (this.startTime !== null && this.startTime !== undefined) {
    output.writeFieldBegin('startTime', Thrift.Type.I64, 3);
    output.writeI64(this.startTime);
    output.writeFieldEnd();
  }
  if (this.txNode !== null && this.txNode !== undefined) {
    output.writeFieldBegin('txNode', Thrift.Type.STRING, 4);
    output.writeString(this.txNode);
    output.writeFieldEnd();
  }
  if (this.rxNodes !== null && this.rxNodes !== undefined) {
    output.writeFieldBegin('rxNodes', Thrift.Type.LIST, 5);
    output.writeListBegin(Thrift.Type.STRING, this.rxNodes.length);
    for (let iter377 in this.rxNodes) {
      if (this.rxNodes.hasOwnProperty(iter377)) {
        iter377 = this.rxNodes[iter377];
        output.writeString(iter377);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.beams !== null && this.beams !== undefined) {
    output.writeFieldBegin('beams', Thrift.Type.LIST, 6);
    output.writeListBegin(Thrift.Type.STRUCT, this.beams.length);
    for (let iter378 in this.beams) {
      if (this.beams.hasOwnProperty(iter378)) {
        iter378 = this.beams[iter378];
        iter378.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.apply !== null && this.apply !== undefined) {
    output.writeFieldBegin('apply', Thrift.Type.BOOL, 7);
    output.writeBool(this.apply);
    output.writeFieldEnd();
  }
  if (this.rtCalType !== null && this.rtCalType !== undefined) {
    output.writeFieldBegin('rtCalType', Thrift.Type.I32, 8);
    output.writeI32(this.rtCalType);
    output.writeFieldEnd();
  }
  if (this.bwgdLen !== null && this.bwgdLen !== undefined) {
    output.writeFieldBegin('bwgdLen', Thrift.Type.BYTE, 9);
    output.writeByte(this.bwgdLen);
    output.writeFieldEnd();
  }
  if (this.txPwrIndex !== null && this.txPwrIndex !== undefined) {
    output.writeFieldBegin('txPwrIndex', Thrift.Type.I16, 10);
    output.writeI16(this.txPwrIndex);
    output.writeFieldEnd();
  }
  if (this.mainTxNode !== null && this.mainTxNode !== undefined) {
    output.writeFieldBegin('mainTxNode', Thrift.Type.STRING, 11);
    output.writeString(this.mainTxNode);
    output.writeFieldEnd();
  }
  if (this.mainRxNode !== null && this.mainRxNode !== undefined) {
    output.writeFieldBegin('mainRxNode', Thrift.Type.STRING, 12);
    output.writeString(this.mainRxNode);
    output.writeFieldEnd();
  }
  if (this.auxTxNodes !== null && this.auxTxNodes !== undefined) {
    output.writeFieldBegin('auxTxNodes', Thrift.Type.LIST, 13);
    output.writeListBegin(Thrift.Type.STRING, this.auxTxNodes.length);
    for (let iter379 in this.auxTxNodes) {
      if (this.auxTxNodes.hasOwnProperty(iter379)) {
        iter379 = this.auxTxNodes[iter379];
        output.writeString(iter379);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.auxRxNodes !== null && this.auxRxNodes !== undefined) {
    output.writeFieldBegin('auxRxNodes', Thrift.Type.LIST, 14);
    output.writeListBegin(Thrift.Type.STRING, this.auxRxNodes.length);
    for (let iter380 in this.auxRxNodes) {
      if (this.auxRxNodes.hasOwnProperty(iter380)) {
        iter380 = this.auxRxNodes[iter380];
        output.writeString(iter380);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.auxTxPwrIndex !== null && this.auxTxPwrIndex !== undefined) {
    output.writeFieldBegin('auxTxPwrIndex', Thrift.Type.LIST, 15);
    output.writeListBegin(Thrift.Type.I16, this.auxTxPwrIndex.length);
    for (let iter381 in this.auxTxPwrIndex) {
      if (this.auxTxPwrIndex.hasOwnProperty(iter381)) {
        iter381 = this.auxTxPwrIndex[iter381];
        output.writeI16(iter381);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.nullAngle !== null && this.nullAngle !== undefined) {
    output.writeFieldBegin('nullAngle', Thrift.Type.I16, 16);
    output.writeI16(this.nullAngle);
    output.writeFieldEnd();
  }
  if (this.cbfBeamIdx !== null && this.cbfBeamIdx !== undefined) {
    output.writeFieldBegin('cbfBeamIdx', Thrift.Type.I16, 17);
    output.writeI16(this.cbfBeamIdx);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetScanStatus = module.exports.GetScanStatus = function(args) {
  this.isConcise = null;
  this.tokenFrom = null;
  this.tokenTo = null;
  if (args) {
    if (args.isConcise !== undefined && args.isConcise !== null) {
      this.isConcise = args.isConcise;
    }
    if (args.tokenFrom !== undefined && args.tokenFrom !== null) {
      this.tokenFrom = args.tokenFrom;
    }
    if (args.tokenTo !== undefined && args.tokenTo !== null) {
      this.tokenTo = args.tokenTo;
    }
  }
};
GetScanStatus.prototype = {};
GetScanStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.isConcise = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.tokenFrom = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.tokenTo = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetScanStatus.prototype.write = function(output) {
  output.writeStructBegin('GetScanStatus');
  if (this.isConcise !== null && this.isConcise !== undefined) {
    output.writeFieldBegin('isConcise', Thrift.Type.BOOL, 1);
    output.writeBool(this.isConcise);
    output.writeFieldEnd();
  }
  if (this.tokenFrom !== null && this.tokenFrom !== undefined) {
    output.writeFieldBegin('tokenFrom', Thrift.Type.I32, 2);
    output.writeI32(this.tokenFrom);
    output.writeFieldEnd();
  }
  if (this.tokenTo !== null && this.tokenTo !== undefined) {
    output.writeFieldBegin('tokenTo', Thrift.Type.I32, 3);
    output.writeI32(this.tokenTo);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ResetScanStatus = module.exports.ResetScanStatus = function(args) {
  this.tokenFrom = null;
  this.tokenTo = null;
  if (args) {
    if (args.tokenFrom !== undefined && args.tokenFrom !== null) {
      this.tokenFrom = args.tokenFrom;
    }
    if (args.tokenTo !== undefined && args.tokenTo !== null) {
      this.tokenTo = args.tokenTo;
    }
  }
};
ResetScanStatus.prototype = {};
ResetScanStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.tokenFrom = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.tokenTo = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ResetScanStatus.prototype.write = function(output) {
  output.writeStructBegin('ResetScanStatus');
  if (this.tokenFrom !== null && this.tokenFrom !== undefined) {
    output.writeFieldBegin('tokenFrom', Thrift.Type.I32, 1);
    output.writeI32(this.tokenFrom);
    output.writeFieldEnd();
  }
  if (this.tokenTo !== null && this.tokenTo !== undefined) {
    output.writeFieldBegin('tokenTo', Thrift.Type.I32, 2);
    output.writeI32(this.tokenTo);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ScanData = module.exports.ScanData = function(args) {
  this.responses = null;
  this.txNode = null;
  this.startBwgdIdx = null;
  this.type = null;
  this.subType = null;
  this.mode = null;
  this.apply = null;
  if (args) {
    if (args.responses !== undefined && args.responses !== null) {
      this.responses = Thrift.copyMap(args.responses, [ttypes.ScanResp]);
    }
    if (args.txNode !== undefined && args.txNode !== null) {
      this.txNode = args.txNode;
    }
    if (args.startBwgdIdx !== undefined && args.startBwgdIdx !== null) {
      this.startBwgdIdx = args.startBwgdIdx;
    }
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    }
    if (args.subType !== undefined && args.subType !== null) {
      this.subType = args.subType;
    }
    if (args.mode !== undefined && args.mode !== null) {
      this.mode = args.mode;
    }
    if (args.apply !== undefined && args.apply !== null) {
      this.apply = args.apply;
    }
  }
};
ScanData.prototype = {};
ScanData.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size382 = 0;
        var _rtmp3386;
        this.responses = {};
        let _ktype383 = 0;
        let _vtype384 = 0;
        _rtmp3386 = input.readMapBegin();
        _ktype383 = _rtmp3386.ktype;
        _vtype384 = _rtmp3386.vtype;
        _size382 = _rtmp3386.size;
        for (let _i387 = 0; _i387 < _size382; ++_i387) {
          let key388 = null;
          let val389 = null;
          key388 = input.readString();
          val389 = new ttypes.ScanResp();
          val389.read(input);
          this.responses[key388] = val389;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.txNode = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.startBwgdIdx = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.subType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.mode = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.BOOL) {
        this.apply = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ScanData.prototype.write = function(output) {
  output.writeStructBegin('ScanData');
  if (this.responses !== null && this.responses !== undefined) {
    output.writeFieldBegin('responses', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.responses));
    for (const kiter390 in this.responses) {
      if (this.responses.hasOwnProperty(kiter390)) {
        const viter391 = this.responses[kiter390];
        output.writeString(kiter390);
        viter391.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.txNode !== null && this.txNode !== undefined) {
    output.writeFieldBegin('txNode', Thrift.Type.STRING, 2);
    output.writeString(this.txNode);
    output.writeFieldEnd();
  }
  if (this.startBwgdIdx !== null && this.startBwgdIdx !== undefined) {
    output.writeFieldBegin('startBwgdIdx', Thrift.Type.I64, 3);
    output.writeI64(this.startBwgdIdx);
    output.writeFieldEnd();
  }
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 4);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.subType !== null && this.subType !== undefined) {
    output.writeFieldBegin('subType', Thrift.Type.I32, 5);
    output.writeI32(this.subType);
    output.writeFieldEnd();
  }
  if (this.mode !== null && this.mode !== undefined) {
    output.writeFieldBegin('mode', Thrift.Type.I32, 6);
    output.writeI32(this.mode);
    output.writeFieldEnd();
  }
  if (this.apply !== null && this.apply !== undefined) {
    output.writeFieldBegin('apply', Thrift.Type.BOOL, 7);
    output.writeBool(this.apply);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ScanStatus = module.exports.ScanStatus = function(args) {
  this.scans = null;
  if (args) {
    if (args.scans !== undefined && args.scans !== null) {
      this.scans = Thrift.copyMap(args.scans, [ttypes.ScanData]);
    }
  }
};
ScanStatus.prototype = {};
ScanStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size392 = 0;
        var _rtmp3396;
        this.scans = {};
        let _ktype393 = 0;
        let _vtype394 = 0;
        _rtmp3396 = input.readMapBegin();
        _ktype393 = _rtmp3396.ktype;
        _vtype394 = _rtmp3396.vtype;
        _size392 = _rtmp3396.size;
        for (let _i397 = 0; _i397 < _size392; ++_i397) {
          let key398 = null;
          let val399 = null;
          key398 = input.readI32();
          val399 = new ttypes.ScanData();
          val399.read(input);
          this.scans[key398] = val399;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ScanStatus.prototype.write = function(output) {
  output.writeStructBegin('ScanStatus');
  if (this.scans !== null && this.scans !== undefined) {
    output.writeFieldBegin('scans', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRUCT, Thrift.objectLength(this.scans));
    for (const kiter400 in this.scans) {
      if (this.scans.hasOwnProperty(kiter400)) {
        const viter401 = this.scans[kiter400];
        output.writeI32(kiter400);
        viter401.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetScanSchedule = module.exports.GetScanSchedule = function(args) {
};
GetScanSchedule.prototype = {};
GetScanSchedule.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetScanSchedule.prototype.write = function(output) {
  output.writeStructBegin('GetScanSchedule');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const ScanSchedule = module.exports.ScanSchedule = function(args) {
  this.imScanTimeoutSec = null;
  this.pbfScanTimeoutSec = null;
  if (args) {
    if (args.imScanTimeoutSec !== undefined && args.imScanTimeoutSec !== null) {
      this.imScanTimeoutSec = args.imScanTimeoutSec;
    }
    if (args.pbfScanTimeoutSec !== undefined && args.pbfScanTimeoutSec !== null) {
      this.pbfScanTimeoutSec = args.pbfScanTimeoutSec;
    }
  }
};
ScanSchedule.prototype = {};
ScanSchedule.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.imScanTimeoutSec = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.pbfScanTimeoutSec = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ScanSchedule.prototype.write = function(output) {
  output.writeStructBegin('ScanSchedule');
  if (this.imScanTimeoutSec !== null && this.imScanTimeoutSec !== undefined) {
    output.writeFieldBegin('imScanTimeoutSec', Thrift.Type.I32, 1);
    output.writeI32(this.imScanTimeoutSec);
    output.writeFieldEnd();
  }
  if (this.pbfScanTimeoutSec !== null && this.pbfScanTimeoutSec !== undefined) {
    output.writeFieldBegin('pbfScanTimeoutSec', Thrift.Type.I32, 2);
    output.writeI32(this.pbfScanTimeoutSec);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetSlotMapConfig = module.exports.GetSlotMapConfig = function(args) {
};
GetSlotMapConfig.prototype = {};
GetSlotMapConfig.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetSlotMapConfig.prototype.write = function(output) {
  output.writeStructBegin('GetSlotMapConfig');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const Slot = module.exports.Slot = function(args) {
  this.start = null;
  this.len = null;
  if (args) {
    if (args.start !== undefined && args.start !== null) {
      this.start = args.start;
    }
    if (args.len !== undefined && args.len !== null) {
      this.len = args.len;
    }
  }
};
Slot.prototype = {};
Slot.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.start = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.len = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Slot.prototype.write = function(output) {
  output.writeStructBegin('Slot');
  if (this.start !== null && this.start !== undefined) {
    output.writeFieldBegin('start', Thrift.Type.I32, 1);
    output.writeI32(this.start);
    output.writeFieldEnd();
  }
  if (this.len !== null && this.len !== undefined) {
    output.writeFieldBegin('len', Thrift.Type.I32, 2);
    output.writeI32(this.len);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SlotMapConfig = module.exports.SlotMapConfig = function(args) {
  this.slotLen = null;
  this.periodLen = null;
  this.mapping = null;
  if (args) {
    if (args.slotLen !== undefined && args.slotLen !== null) {
      this.slotLen = args.slotLen;
    }
    if (args.periodLen !== undefined && args.periodLen !== null) {
      this.periodLen = args.periodLen;
    }
    if (args.mapping !== undefined && args.mapping !== null) {
      this.mapping = Thrift.copyMap(args.mapping, [Thrift.copyList, ttypes.Slot]);
    }
  }
};
SlotMapConfig.prototype = {};
SlotMapConfig.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.slotLen = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.periodLen = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.MAP) {
        let _size402 = 0;
        var _rtmp3406;
        this.mapping = {};
        let _ktype403 = 0;
        let _vtype404 = 0;
        _rtmp3406 = input.readMapBegin();
        _ktype403 = _rtmp3406.ktype;
        _vtype404 = _rtmp3406.vtype;
        _size402 = _rtmp3406.size;
        for (let _i407 = 0; _i407 < _size402; ++_i407) {
          let key408 = null;
          let val409 = null;
          key408 = input.readI32();
          let _size410 = 0;
          var _rtmp3414;
          val409 = [];
          let _etype413 = 0;
          _rtmp3414 = input.readListBegin();
          _etype413 = _rtmp3414.etype;
          _size410 = _rtmp3414.size;
          for (let _i415 = 0; _i415 < _size410; ++_i415) {
            let elem416 = null;
            elem416 = new ttypes.Slot();
            elem416.read(input);
            val409.push(elem416);
          }
          input.readListEnd();
          this.mapping[key408] = val409;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SlotMapConfig.prototype.write = function(output) {
  output.writeStructBegin('SlotMapConfig');
  if (this.slotLen !== null && this.slotLen !== undefined) {
    output.writeFieldBegin('slotLen', Thrift.Type.I32, 1);
    output.writeI32(this.slotLen);
    output.writeFieldEnd();
  }
  if (this.periodLen !== null && this.periodLen !== undefined) {
    output.writeFieldBegin('periodLen', Thrift.Type.I32, 2);
    output.writeI32(this.periodLen);
    output.writeFieldEnd();
  }
  if (this.mapping !== null && this.mapping !== undefined) {
    output.writeFieldBegin('mapping', Thrift.Type.MAP, 3);
    output.writeMapBegin(Thrift.Type.I32, Thrift.Type.LIST, Thrift.objectLength(this.mapping));
    for (const kiter417 in this.mapping) {
      if (this.mapping.hasOwnProperty(kiter417)) {
        const viter418 = this.mapping[kiter417];
        output.writeI32(kiter417);
        output.writeListBegin(Thrift.Type.STRUCT, viter418.length);
        for (let iter419 in viter418) {
          if (viter418.hasOwnProperty(iter419)) {
            iter419 = viter418[iter419];
            iter419.write(output);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SyncLinkMonitor = module.exports.SyncLinkMonitor = function(args) {
};
SyncLinkMonitor.prototype = {};
SyncLinkMonitor.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SyncLinkMonitor.prototype.write = function(output) {
  output.writeStructBegin('SyncLinkMonitor');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const InjectKvStoreKeys = module.exports.InjectKvStoreKeys = function(args) {
};
InjectKvStoreKeys.prototype = {};
InjectKvStoreKeys.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

InjectKvStoreKeys.prototype.write = function(output) {
  output.writeStructBegin('InjectKvStoreKeys');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetRoutingAdjacencies = module.exports.GetRoutingAdjacencies = function(args) {
};
GetRoutingAdjacencies.prototype = {};
GetRoutingAdjacencies.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetRoutingAdjacencies.prototype.write = function(output) {
  output.writeStructBegin('GetRoutingAdjacencies');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const RoutingAdjacencies = module.exports.RoutingAdjacencies = function(args) {
  this.adjacencyMap = null;
  this.prefixMap = null;
  if (args) {
    if (args.adjacencyMap !== undefined && args.adjacencyMap !== null) {
      this.adjacencyMap = Thrift.copyMap(args.adjacencyMap, [Lsdb_ttypes.AdjacencyDatabase]);
    }
    if (args.prefixMap !== undefined && args.prefixMap !== null) {
      this.prefixMap = Thrift.copyMap(args.prefixMap, [Lsdb_ttypes.PrefixDatabase]);
    }
  }
};
RoutingAdjacencies.prototype = {};
RoutingAdjacencies.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size420 = 0;
        var _rtmp3424;
        this.adjacencyMap = {};
        let _ktype421 = 0;
        let _vtype422 = 0;
        _rtmp3424 = input.readMapBegin();
        _ktype421 = _rtmp3424.ktype;
        _vtype422 = _rtmp3424.vtype;
        _size420 = _rtmp3424.size;
        for (let _i425 = 0; _i425 < _size420; ++_i425) {
          let key426 = null;
          let val427 = null;
          key426 = input.readString();
          val427 = new Lsdb_ttypes.AdjacencyDatabase();
          val427.read(input);
          this.adjacencyMap[key426] = val427;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.MAP) {
        let _size428 = 0;
        var _rtmp3432;
        this.prefixMap = {};
        let _ktype429 = 0;
        let _vtype430 = 0;
        _rtmp3432 = input.readMapBegin();
        _ktype429 = _rtmp3432.ktype;
        _vtype430 = _rtmp3432.vtype;
        _size428 = _rtmp3432.size;
        for (let _i433 = 0; _i433 < _size428; ++_i433) {
          let key434 = null;
          let val435 = null;
          key434 = input.readString();
          val435 = new Lsdb_ttypes.PrefixDatabase();
          val435.read(input);
          this.prefixMap[key434] = val435;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

RoutingAdjacencies.prototype.write = function(output) {
  output.writeStructBegin('RoutingAdjacencies');
  if (this.adjacencyMap !== null && this.adjacencyMap !== undefined) {
    output.writeFieldBegin('adjacencyMap', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.adjacencyMap));
    for (const kiter436 in this.adjacencyMap) {
      if (this.adjacencyMap.hasOwnProperty(kiter436)) {
        const viter437 = this.adjacencyMap[kiter436];
        output.writeString(kiter436);
        viter437.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.prefixMap !== null && this.prefixMap !== undefined) {
    output.writeFieldBegin('prefixMap', Thrift.Type.MAP, 2);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.prefixMap));
    for (const kiter438 in this.prefixMap) {
      if (this.prefixMap.hasOwnProperty(kiter438)) {
        const viter439 = this.prefixMap[kiter438];
        output.writeString(kiter438);
        viter439.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const SetLinkMetric = module.exports.SetLinkMetric = function(args) {
  this.macAddr = null;
  this.metric = null;
  if (args) {
    if (args.macAddr !== undefined && args.macAddr !== null) {
      this.macAddr = args.macAddr;
    }
    if (args.metric !== undefined && args.metric !== null) {
      this.metric = args.metric;
    }
  }
};
SetLinkMetric.prototype = {};
SetLinkMetric.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.macAddr = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.metric = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

SetLinkMetric.prototype.write = function(output) {
  output.writeStructBegin('SetLinkMetric');
  if (this.macAddr !== null && this.macAddr !== undefined) {
    output.writeFieldBegin('macAddr', Thrift.Type.STRING, 1);
    output.writeString(this.macAddr);
    output.writeFieldEnd();
  }
  if (this.metric !== null && this.metric !== undefined) {
    output.writeFieldBegin('metric', Thrift.Type.I32, 2);
    output.writeI32(this.metric);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const IperfOptions = module.exports.IperfOptions = function(args) {
  this.bitrate = null;
  this.timeSec = null;
  this.protocol = null;
  this.intervalSec = null;
  this.windowSize = null;
  this.mss = null;
  this.noDelay = null;
  this.omitSec = null;
  this.verbose = null;
  if (args) {
    if (args.bitrate !== undefined && args.bitrate !== null) {
      this.bitrate = args.bitrate;
    }
    if (args.timeSec !== undefined && args.timeSec !== null) {
      this.timeSec = args.timeSec;
    }
    if (args.protocol !== undefined && args.protocol !== null) {
      this.protocol = args.protocol;
    }
    if (args.intervalSec !== undefined && args.intervalSec !== null) {
      this.intervalSec = args.intervalSec;
    }
    if (args.windowSize !== undefined && args.windowSize !== null) {
      this.windowSize = args.windowSize;
    }
    if (args.mss !== undefined && args.mss !== null) {
      this.mss = args.mss;
    }
    if (args.noDelay !== undefined && args.noDelay !== null) {
      this.noDelay = args.noDelay;
    }
    if (args.omitSec !== undefined && args.omitSec !== null) {
      this.omitSec = args.omitSec;
    }
    if (args.verbose !== undefined && args.verbose !== null) {
      this.verbose = args.verbose;
    }
  }
};
IperfOptions.prototype = {};
IperfOptions.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.bitrate = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.timeSec = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.protocol = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.intervalSec = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.windowSize = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.mss = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.BOOL) {
        this.noDelay = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I32) {
        this.omitSec = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.BOOL) {
        this.verbose = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IperfOptions.prototype.write = function(output) {
  output.writeStructBegin('IperfOptions');
  if (this.bitrate !== null && this.bitrate !== undefined) {
    output.writeFieldBegin('bitrate', Thrift.Type.I64, 1);
    output.writeI64(this.bitrate);
    output.writeFieldEnd();
  }
  if (this.timeSec !== null && this.timeSec !== undefined) {
    output.writeFieldBegin('timeSec', Thrift.Type.I32, 2);
    output.writeI32(this.timeSec);
    output.writeFieldEnd();
  }
  if (this.protocol !== null && this.protocol !== undefined) {
    output.writeFieldBegin('protocol', Thrift.Type.I32, 3);
    output.writeI32(this.protocol);
    output.writeFieldEnd();
  }
  if (this.intervalSec !== null && this.intervalSec !== undefined) {
    output.writeFieldBegin('intervalSec', Thrift.Type.I32, 4);
    output.writeI32(this.intervalSec);
    output.writeFieldEnd();
  }
  if (this.windowSize !== null && this.windowSize !== undefined) {
    output.writeFieldBegin('windowSize', Thrift.Type.I64, 5);
    output.writeI64(this.windowSize);
    output.writeFieldEnd();
  }
  if (this.mss !== null && this.mss !== undefined) {
    output.writeFieldBegin('mss', Thrift.Type.I32, 6);
    output.writeI32(this.mss);
    output.writeFieldEnd();
  }
  if (this.noDelay !== null && this.noDelay !== undefined) {
    output.writeFieldBegin('noDelay', Thrift.Type.BOOL, 7);
    output.writeBool(this.noDelay);
    output.writeFieldEnd();
  }
  if (this.omitSec !== null && this.omitSec !== undefined) {
    output.writeFieldBegin('omitSec', Thrift.Type.I32, 8);
    output.writeI32(this.omitSec);
    output.writeFieldEnd();
  }
  if (this.verbose !== null && this.verbose !== undefined) {
    output.writeFieldBegin('verbose', Thrift.Type.BOOL, 9);
    output.writeBool(this.verbose);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StartIperf = module.exports.StartIperf = function(args) {
  this.srcNodeId = null;
  this.dstNodeId = null;
  this.dstNodeIpv6 = null;
  this.options = null;
  if (args) {
    if (args.srcNodeId !== undefined && args.srcNodeId !== null) {
      this.srcNodeId = args.srcNodeId;
    }
    if (args.dstNodeId !== undefined && args.dstNodeId !== null) {
      this.dstNodeId = args.dstNodeId;
    }
    if (args.dstNodeIpv6 !== undefined && args.dstNodeIpv6 !== null) {
      this.dstNodeIpv6 = args.dstNodeIpv6;
    }
    if (args.options !== undefined && args.options !== null) {
      this.options = new ttypes.IperfOptions(args.options);
    }
  }
};
StartIperf.prototype = {};
StartIperf.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.srcNodeId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.dstNodeId = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.dstNodeIpv6 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.options = new ttypes.IperfOptions();
        this.options.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StartIperf.prototype.write = function(output) {
  output.writeStructBegin('StartIperf');
  if (this.srcNodeId !== null && this.srcNodeId !== undefined) {
    output.writeFieldBegin('srcNodeId', Thrift.Type.STRING, 1);
    output.writeString(this.srcNodeId);
    output.writeFieldEnd();
  }
  if (this.dstNodeId !== null && this.dstNodeId !== undefined) {
    output.writeFieldBegin('dstNodeId', Thrift.Type.STRING, 2);
    output.writeString(this.dstNodeId);
    output.writeFieldEnd();
  }
  if (this.dstNodeIpv6 !== null && this.dstNodeIpv6 !== undefined) {
    output.writeFieldBegin('dstNodeIpv6', Thrift.Type.STRING, 3);
    output.writeString(this.dstNodeIpv6);
    output.writeFieldEnd();
  }
  if (this.options !== null && this.options !== undefined) {
    output.writeFieldBegin('options', Thrift.Type.STRUCT, 4);
    this.options.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StartIperfResp = module.exports.StartIperfResp = function(args) {
  this.id = null;
  if (args) {
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    }
  }
};
StartIperfResp.prototype = {};
StartIperfResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.id = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StartIperfResp.prototype.write = function(output) {
  output.writeStructBegin('StartIperfResp');
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.STRING, 1);
    output.writeString(this.id);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StartMinionIperf = module.exports.StartMinionIperf = function(args) {
  this.iperfConfig = null;
  this.serverPort = 0;
  this.id = null;
  if (args) {
    if (args.iperfConfig !== undefined && args.iperfConfig !== null) {
      this.iperfConfig = new ttypes.StartIperf(args.iperfConfig);
    }
    if (args.serverPort !== undefined && args.serverPort !== null) {
      this.serverPort = args.serverPort;
    }
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    }
  }
};
StartMinionIperf.prototype = {};
StartMinionIperf.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.iperfConfig = new ttypes.StartIperf();
        this.iperfConfig.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.serverPort = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.id = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StartMinionIperf.prototype.write = function(output) {
  output.writeStructBegin('StartMinionIperf');
  if (this.iperfConfig !== null && this.iperfConfig !== undefined) {
    output.writeFieldBegin('iperfConfig', Thrift.Type.STRUCT, 1);
    this.iperfConfig.write(output);
    output.writeFieldEnd();
  }
  if (this.serverPort !== null && this.serverPort !== undefined) {
    output.writeFieldBegin('serverPort', Thrift.Type.I32, 2);
    output.writeI32(this.serverPort);
    output.writeFieldEnd();
  }
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.STRING, 3);
    output.writeString(this.id);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const StopIperf = module.exports.StopIperf = function(args) {
  this.id = null;
  if (args) {
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    }
  }
};
StopIperf.prototype = {};
StopIperf.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.id = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

StopIperf.prototype.write = function(output) {
  output.writeStructBegin('StopIperf');
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.STRING, 1);
    output.writeString(this.id);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const GetIperfStatus = module.exports.GetIperfStatus = function(args) {
};
GetIperfStatus.prototype = {};
GetIperfStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

GetIperfStatus.prototype.write = function(output) {
  output.writeStructBegin('GetIperfStatus');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const IperfStatus = module.exports.IperfStatus = function(args) {
  this.sessions = null;
  if (args) {
    if (args.sessions !== undefined && args.sessions !== null) {
      this.sessions = Thrift.copyMap(args.sessions, [ttypes.StartMinionIperf]);
    }
  }
};
IperfStatus.prototype = {};
IperfStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        let _size440 = 0;
        var _rtmp3444;
        this.sessions = {};
        let _ktype441 = 0;
        let _vtype442 = 0;
        _rtmp3444 = input.readMapBegin();
        _ktype441 = _rtmp3444.ktype;
        _vtype442 = _rtmp3444.vtype;
        _size440 = _rtmp3444.size;
        for (let _i445 = 0; _i445 < _size440; ++_i445) {
          let key446 = null;
          let val447 = null;
          key446 = input.readString();
          val447 = new ttypes.StartMinionIperf();
          val447.read(input);
          this.sessions[key446] = val447;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IperfStatus.prototype.write = function(output) {
  output.writeStructBegin('IperfStatus');
  if (this.sessions !== null && this.sessions !== undefined) {
    output.writeFieldBegin('sessions', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.sessions));
    for (const kiter448 in this.sessions) {
      if (this.sessions.hasOwnProperty(kiter448)) {
        const viter449 = this.sessions[kiter448];
        output.writeString(kiter448);
        viter449.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const IperfOutput = module.exports.IperfOutput = function(args) {
  this.output = null;
  this.startIperf = null;
  this.isServer = null;
  if (args) {
    if (args.output !== undefined && args.output !== null) {
      this.output = args.output;
    }
    if (args.startIperf !== undefined && args.startIperf !== null) {
      this.startIperf = new ttypes.StartMinionIperf(args.startIperf);
    }
    if (args.isServer !== undefined && args.isServer !== null) {
      this.isServer = args.isServer;
    }
  }
};
IperfOutput.prototype = {};
IperfOutput.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.output = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.startIperf = new ttypes.StartMinionIperf();
        this.startIperf.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.isServer = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IperfOutput.prototype.write = function(output) {
  output.writeStructBegin('IperfOutput');
  if (this.output !== null && this.output !== undefined) {
    output.writeFieldBegin('output', Thrift.Type.STRING, 1);
    output.writeString(this.output);
    output.writeFieldEnd();
  }
  if (this.startIperf !== null && this.startIperf !== undefined) {
    output.writeFieldBegin('startIperf', Thrift.Type.STRUCT, 2);
    this.startIperf.write(output);
    output.writeFieldEnd();
  }
  if (this.isServer !== null && this.isServer !== undefined) {
    output.writeFieldBegin('isServer', Thrift.Type.BOOL, 3);
    output.writeBool(this.isServer);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BinaryStar = module.exports.BinaryStar = function(args) {
  this.state = null;
  this.peerExpiry = null;
  if (args) {
    if (args.state !== undefined && args.state !== null) {
      this.state = args.state;
    }
    if (args.peerExpiry !== undefined && args.peerExpiry !== null) {
      this.peerExpiry = args.peerExpiry;
    }
  }
};
BinaryStar.prototype = {};
BinaryStar.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.state = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.peerExpiry = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BinaryStar.prototype.write = function(output) {
  output.writeStructBegin('BinaryStar');
  if (this.state !== null && this.state !== undefined) {
    output.writeFieldBegin('state', Thrift.Type.I32, 1);
    output.writeI32(this.state);
    output.writeFieldEnd();
  }
  if (this.peerExpiry !== null && this.peerExpiry !== undefined) {
    output.writeFieldBegin('peerExpiry', Thrift.Type.I64, 2);
    output.writeI64(this.peerExpiry);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BinaryStarGetAppData = module.exports.BinaryStarGetAppData = function(args) {
};
BinaryStarGetAppData.prototype = {};
BinaryStarGetAppData.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BinaryStarGetAppData.prototype.write = function(output) {
  output.writeStructBegin('BinaryStarGetAppData');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BinaryStarAppData = module.exports.BinaryStarAppData = function(args) {
  this.topology = null;
  this.configNetworkOverrides = null;
  this.configNodeOverrides = null;
  if (args) {
    if (args.topology !== undefined && args.topology !== null) {
      this.topology = new Topology_ttypes.Topology(args.topology);
    }
    if (args.configNetworkOverrides !== undefined && args.configNetworkOverrides !== null) {
      this.configNetworkOverrides = args.configNetworkOverrides;
    }
    if (args.configNodeOverrides !== undefined && args.configNodeOverrides !== null) {
      this.configNodeOverrides = args.configNodeOverrides;
    }
  }
};
BinaryStarAppData.prototype = {};
BinaryStarAppData.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.topology = new Topology_ttypes.Topology();
        this.topology.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.configNetworkOverrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.configNodeOverrides = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BinaryStarAppData.prototype.write = function(output) {
  output.writeStructBegin('BinaryStarAppData');
  if (this.topology !== null && this.topology !== undefined) {
    output.writeFieldBegin('topology', Thrift.Type.STRUCT, 1);
    this.topology.write(output);
    output.writeFieldEnd();
  }
  if (this.configNetworkOverrides !== null && this.configNetworkOverrides !== undefined) {
    output.writeFieldBegin('configNetworkOverrides', Thrift.Type.STRING, 2);
    output.writeString(this.configNetworkOverrides);
    output.writeFieldEnd();
  }
  if (this.configNodeOverrides !== null && this.configNodeOverrides !== undefined) {
    output.writeFieldBegin('configNodeOverrides', Thrift.Type.STRING, 3);
    output.writeString(this.configNodeOverrides);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BinaryStarSync = module.exports.BinaryStarSync = function(args) {
  this.state = null;
  this.seqNum = null;
  this.data = null;
  if (args) {
    if (args.state !== undefined && args.state !== null) {
      this.state = args.state;
    }
    if (args.seqNum !== undefined && args.seqNum !== null) {
      this.seqNum = args.seqNum;
    }
    if (args.data !== undefined && args.data !== null) {
      this.data = new ttypes.BinaryStarAppData(args.data);
    }
  }
};
BinaryStarSync.prototype = {};
BinaryStarSync.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.state = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.seqNum = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.data = new ttypes.BinaryStarAppData();
        this.data.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BinaryStarSync.prototype.write = function(output) {
  output.writeStructBegin('BinaryStarSync');
  if (this.state !== null && this.state !== undefined) {
    output.writeFieldBegin('state', Thrift.Type.I32, 1);
    output.writeI32(this.state);
    output.writeFieldEnd();
  }
  if (this.seqNum !== null && this.seqNum !== undefined) {
    output.writeFieldBegin('seqNum', Thrift.Type.I32, 2);
    output.writeI32(this.seqNum);
    output.writeFieldEnd();
  }
  if (this.data !== null && this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.STRUCT, 3);
    this.data.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BinaryStarSwitchController = module.exports.BinaryStarSwitchController = function(args) {
};
BinaryStarSwitchController.prototype = {};
BinaryStarSwitchController.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BinaryStarSwitchController.prototype.write = function(output) {
  output.writeStructBegin('BinaryStarSwitchController');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BinaryStarGetState = module.exports.BinaryStarGetState = function(args) {
};
BinaryStarGetState.prototype = {};
BinaryStarGetState.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BinaryStarGetState.prototype.write = function(output) {
  output.writeStructBegin('BinaryStarGetState');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const Message = module.exports.Message = function(args) {
  this.mType = null;
  this.value = null;
  this.compressed = null;
  this.compressionFormat = null;
  if (args) {
    if (args.mType !== undefined && args.mType !== null) {
      this.mType = args.mType;
    }
    if (args.value !== undefined && args.value !== null) {
      this.value = args.value;
    }
    if (args.compressed !== undefined && args.compressed !== null) {
      this.compressed = args.compressed;
    }
    if (args.compressionFormat !== undefined && args.compressionFormat !== null) {
      this.compressionFormat = args.compressionFormat;
    }
  }
};
Message.prototype = {};
Message.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.mType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.value = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.compressed = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.compressionFormat = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Message.prototype.write = function(output) {
  output.writeStructBegin('Message');
  if (this.mType !== null && this.mType !== undefined) {
    output.writeFieldBegin('mType', Thrift.Type.I32, 1);
    output.writeI32(this.mType);
    output.writeFieldEnd();
  }
  if (this.value !== null && this.value !== undefined) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 2);
    output.writeBinary(this.value);
    output.writeFieldEnd();
  }
  if (this.compressed !== null && this.compressed !== undefined) {
    output.writeFieldBegin('compressed', Thrift.Type.BOOL, 3);
    output.writeBool(this.compressed);
    output.writeFieldEnd();
  }
  if (this.compressionFormat !== null && this.compressionFormat !== undefined) {
    output.writeFieldBegin('compressionFormat', Thrift.Type.I32, 4);
    output.writeI32(this.compressionFormat);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const Hello = module.exports.Hello = function(args) {
};
Hello.prototype = {};
Hello.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Hello.prototype.write = function(output) {
  output.writeStructBegin('Hello');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const E2EAck = module.exports.E2EAck = function(args) {
  this.success = null;
  this.message = null;
  if (args) {
    if (args.success !== undefined && args.success !== null) {
      this.success = args.success;
    }
    if (args.message !== undefined && args.message !== null) {
      this.message = args.message;
    }
  }
};
E2EAck.prototype = {};
E2EAck.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.success = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

E2EAck.prototype.write = function(output) {
  output.writeStructBegin('E2EAck');
  if (this.success !== null && this.success !== undefined) {
    output.writeFieldBegin('success', Thrift.Type.BOOL, 1);
    output.writeBool(this.success);
    output.writeFieldEnd();
  }
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 2);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BgpNeighbor = module.exports.BgpNeighbor = function(args) {
  this.asn = null;
  this.ipv6 = null;
  if (args) {
    if (args.asn !== undefined && args.asn !== null) {
      this.asn = args.asn;
    }
    if (args.ipv6 !== undefined && args.ipv6 !== null) {
      this.ipv6 = args.ipv6;
    }
  }
};
BgpNeighbor.prototype = {};
BgpNeighbor.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.asn = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.ipv6 = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BgpNeighbor.prototype.write = function(output) {
  output.writeStructBegin('BgpNeighbor');
  if (this.asn !== null && this.asn !== undefined) {
    output.writeFieldBegin('asn', Thrift.Type.I64, 1);
    output.writeI64(this.asn);
    output.writeFieldEnd();
  }
  if (this.ipv6 !== null && this.ipv6 !== undefined) {
    output.writeFieldBegin('ipv6', Thrift.Type.STRING, 2);
    output.writeString(this.ipv6);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BgpNeighbors = module.exports.BgpNeighbors = function(args) {
  this.neighbors = null;
  if (args) {
    if (args.neighbors !== undefined && args.neighbors !== null) {
      this.neighbors = Thrift.copyList(args.neighbors, [ttypes.BgpNeighbor]);
    }
  }
};
BgpNeighbors.prototype = {};
BgpNeighbors.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        let _size450 = 0;
        var _rtmp3454;
        this.neighbors = [];
        let _etype453 = 0;
        _rtmp3454 = input.readListBegin();
        _etype453 = _rtmp3454.etype;
        _size450 = _rtmp3454.size;
        for (let _i455 = 0; _i455 < _size450; ++_i455) {
          let elem456 = null;
          elem456 = new ttypes.BgpNeighbor();
          elem456.read(input);
          this.neighbors.push(elem456);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BgpNeighbors.prototype.write = function(output) {
  output.writeStructBegin('BgpNeighbors');
  if (this.neighbors !== null && this.neighbors !== undefined) {
    output.writeFieldBegin('neighbors', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.neighbors.length);
    for (let iter457 in this.neighbors) {
      if (this.neighbors.hasOwnProperty(iter457)) {
        iter457 = this.neighbors[iter457];
        iter457.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const BgpConfig = module.exports.BgpConfig = function(args) {
  this.localAsn = null;
  this.neighbors = null;
  if (args) {
    if (args.localAsn !== undefined && args.localAsn !== null) {
      this.localAsn = args.localAsn;
    }
    if (args.neighbors !== undefined && args.neighbors !== null) {
      this.neighbors = Thrift.copyList(args.neighbors, [ttypes.BgpNeighbor]);
    }
  }
};
BgpConfig.prototype = {};
BgpConfig.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.localAsn = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        let _size458 = 0;
        var _rtmp3462;
        this.neighbors = [];
        let _etype461 = 0;
        _rtmp3462 = input.readListBegin();
        _etype461 = _rtmp3462.etype;
        _size458 = _rtmp3462.size;
        for (let _i463 = 0; _i463 < _size458; ++_i463) {
          let elem464 = null;
          elem464 = new ttypes.BgpNeighbor();
          elem464.read(input);
          this.neighbors.push(elem464);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BgpConfig.prototype.write = function(output) {
  output.writeStructBegin('BgpConfig');
  if (this.localAsn !== null && this.localAsn !== undefined) {
    output.writeFieldBegin('localAsn', Thrift.Type.I64, 1);
    output.writeI64(this.localAsn);
    output.writeFieldEnd();
  }
  if (this.neighbors !== null && this.neighbors !== undefined) {
    output.writeFieldBegin('neighbors', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.neighbors.length);
    for (let iter465 in this.neighbors) {
      if (this.neighbors.hasOwnProperty(iter465)) {
        iter465 = this.neighbors[iter465];
        iter465.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const NetworkInfo = module.exports.NetworkInfo = function(args) {
  this.e2eCtrlUrl = null;
  this.e2eCtrlUrlBackup = null;
  this.aggrCtrlUrl = null;
  this.network = null;
  this.bgpNeighbors = null;
  this.bgpConfig = null;
  this.dhcpNameServer = null;
  this.dhcpRangeMin = null;
  this.dhcpRangeMax = null;
  this.dhcpGlobalConfigAppend = null;
  if (args) {
    if (args.e2eCtrlUrl !== undefined && args.e2eCtrlUrl !== null) {
      this.e2eCtrlUrl = args.e2eCtrlUrl;
    }
    if (args.e2eCtrlUrlBackup !== undefined && args.e2eCtrlUrlBackup !== null) {
      this.e2eCtrlUrlBackup = args.e2eCtrlUrlBackup;
    }
    if (args.aggrCtrlUrl !== undefined && args.aggrCtrlUrl !== null) {
      this.aggrCtrlUrl = Thrift.copyList(args.aggrCtrlUrl, [null]);
    }
    if (args.network !== undefined && args.network !== null) {
      this.network = args.network;
    }
    if (args.bgpNeighbors !== undefined && args.bgpNeighbors !== null) {
      this.bgpNeighbors = new ttypes.BgpNeighbors(args.bgpNeighbors);
    }
    if (args.bgpConfig !== undefined && args.bgpConfig !== null) {
      this.bgpConfig = new ttypes.BgpConfig(args.bgpConfig);
    }
    if (args.dhcpNameServer !== undefined && args.dhcpNameServer !== null) {
      this.dhcpNameServer = args.dhcpNameServer;
    }
    if (args.dhcpRangeMin !== undefined && args.dhcpRangeMin !== null) {
      this.dhcpRangeMin = args.dhcpRangeMin;
    }
    if (args.dhcpRangeMax !== undefined && args.dhcpRangeMax !== null) {
      this.dhcpRangeMax = args.dhcpRangeMax;
    }
    if (args.dhcpGlobalConfigAppend !== undefined && args.dhcpGlobalConfigAppend !== null) {
      this.dhcpGlobalConfigAppend = args.dhcpGlobalConfigAppend;
    }
  }
};
NetworkInfo.prototype = {};
NetworkInfo.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.e2eCtrlUrl = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.e2eCtrlUrlBackup = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        let _size466 = 0;
        var _rtmp3470;
        this.aggrCtrlUrl = [];
        let _etype469 = 0;
        _rtmp3470 = input.readListBegin();
        _etype469 = _rtmp3470.etype;
        _size466 = _rtmp3470.size;
        for (let _i471 = 0; _i471 < _size466; ++_i471) {
          let elem472 = null;
          elem472 = input.readString();
          this.aggrCtrlUrl.push(elem472);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.network = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.bgpNeighbors = new ttypes.BgpNeighbors();
        this.bgpNeighbors.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.bgpConfig = new ttypes.BgpConfig();
        this.bgpConfig.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.dhcpNameServer = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I64) {
        this.dhcpRangeMin = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I64) {
        this.dhcpRangeMax = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRING) {
        this.dhcpGlobalConfigAppend = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NetworkInfo.prototype.write = function(output) {
  output.writeStructBegin('NetworkInfo');
  if (this.e2eCtrlUrl !== null && this.e2eCtrlUrl !== undefined) {
    output.writeFieldBegin('e2eCtrlUrl', Thrift.Type.STRING, 1);
    output.writeString(this.e2eCtrlUrl);
    output.writeFieldEnd();
  }
  if (this.e2eCtrlUrlBackup !== null && this.e2eCtrlUrlBackup !== undefined) {
    output.writeFieldBegin('e2eCtrlUrlBackup', Thrift.Type.STRING, 2);
    output.writeString(this.e2eCtrlUrlBackup);
    output.writeFieldEnd();
  }
  if (this.aggrCtrlUrl !== null && this.aggrCtrlUrl !== undefined) {
    output.writeFieldBegin('aggrCtrlUrl', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRING, this.aggrCtrlUrl.length);
    for (let iter473 in this.aggrCtrlUrl) {
      if (this.aggrCtrlUrl.hasOwnProperty(iter473)) {
        iter473 = this.aggrCtrlUrl[iter473];
        output.writeString(iter473);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.network !== null && this.network !== undefined) {
    output.writeFieldBegin('network', Thrift.Type.STRING, 4);
    output.writeString(this.network);
    output.writeFieldEnd();
  }
  if (this.bgpNeighbors !== null && this.bgpNeighbors !== undefined) {
    output.writeFieldBegin('bgpNeighbors', Thrift.Type.STRUCT, 5);
    this.bgpNeighbors.write(output);
    output.writeFieldEnd();
  }
  if (this.bgpConfig !== null && this.bgpConfig !== undefined) {
    output.writeFieldBegin('bgpConfig', Thrift.Type.STRUCT, 6);
    this.bgpConfig.write(output);
    output.writeFieldEnd();
  }
  if (this.dhcpNameServer !== null && this.dhcpNameServer !== undefined) {
    output.writeFieldBegin('dhcpNameServer', Thrift.Type.STRING, 7);
    output.writeString(this.dhcpNameServer);
    output.writeFieldEnd();
  }
  if (this.dhcpRangeMin !== null && this.dhcpRangeMin !== undefined) {
    output.writeFieldBegin('dhcpRangeMin', Thrift.Type.I64, 8);
    output.writeI64(this.dhcpRangeMin);
    output.writeFieldEnd();
  }
  if (this.dhcpRangeMax !== null && this.dhcpRangeMax !== undefined) {
    output.writeFieldBegin('dhcpRangeMax', Thrift.Type.I64, 9);
    output.writeI64(this.dhcpRangeMax);
    output.writeFieldEnd();
  }
  if (this.dhcpGlobalConfigAppend !== null && this.dhcpGlobalConfigAppend !== undefined) {
    output.writeFieldBegin('dhcpGlobalConfigAppend', Thrift.Type.STRING, 10);
    output.writeString(this.dhcpGlobalConfigAppend);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const Empty = module.exports.Empty = function(args) {
};
Empty.prototype = {};
Empty.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    const ret = input.readFieldBegin();
    const fname = ret.fname;
    const ftype = ret.ftype;
    const fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Empty.prototype.write = function(output) {
  output.writeStructBegin('Empty');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

