/**
 * Generated by `js1 upgrade www-shared`.
 * @generated SignedSource<<94ad880d615814cec83a19880ad4a7de>>
 *
 * Copyright 2004-present Facebook. All Rights Reserved.
 */

'use strict';

var nodeTypes = [
  'ArrowFunctionExpression',
  'ClassDeclaration',
  'ClassProperty',
  'DeclareClass',
  'DeclareFunction',
  'DeclareModule',
  'DeclareVariable',
  'FunctionDeclaration',
  'FunctionExpression',
  'Identifier',
  'MethodDefinition',
  'TypeAlias',
];

var propsToCheck = [
  'typeAnnotation',
  'returnType',
  'elementType',
];

function traverseTypeAnnotations(checkNode, options) {
  const ignoreTypesInFunctionAndClassDeclaration =
    options && options.ignoreTypesInFunctionAndClassDeclaration;

  function traverseNode(node) {
    if (!node) {
      return;
    }

    checkNode(node);

    if (node.type === 'TypeAlias') {
      traverseNode(node.right);
    }

    if (node.type === 'ObjectTypeAnnotation') {
      node.callProperties.forEach(traverseNode);
      node.indexers.forEach(traverseNode);
      node.properties.forEach(traverseNode);
    }

    if (
      node.type === 'ObjectTypeProperty' ||
      node.type === 'ObjectTypeIndexer'
    ) {
      traverseNode(node.key);
      traverseNode(node.value);
    }

    if (node.type === 'ObjectTypeCallProperty') {
      traverseNode(node.value);
    }

    if (node.type === 'FunctionTypeAnnotation') {
      node.params.forEach(traverseNode);
    }

    if (
      node.type === 'UnionTypeAnnotation' ||
      node.type === 'IntersectionTypeAnnotation'
    ) {
      node.types.forEach(traverseNode);
    }

    if (node.type === 'DeclareClass') {
      traverseNode(node.body);
      node.extends.forEach(traverseNode);
    }

    // Ignore typeParameters on function and class declarations, as the only use
    // case for this is bounded polymorphism
    // https://flow.org/blog/2015/03/12/Bounded-Polymorphism/
    if (
      node.typeParameters && (
        !ignoreTypesInFunctionAndClassDeclaration || (
          node.type !== 'FunctionDeclaration' &&
          node.type !== 'ClassDeclaration'
        )
      )
    ) {
      node.typeParameters.params.forEach(traverseNode);
    }

    if (node.superTypeParameters) {
      node.superTypeParameters.params.forEach(traverseNode);
    }

    propsToCheck
      .map(prop => node[prop])
      .filter(value => value)
      .forEach(traverseNode);
  }

  var result = {};
  nodeTypes.forEach(nodeType => result[nodeType] = traverseNode);
  return result;
}

module.exports = traverseTypeAnnotations;
