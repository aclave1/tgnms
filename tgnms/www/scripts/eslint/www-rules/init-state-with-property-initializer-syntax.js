/**
 * Generated by `js1 upgrade www-shared`.
 * @generated SignedSource<<61b36b86c844bc4d97e6148127c41e70>>
 *
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @format
 */

'use strict';

const isReactClass = require('./utils/isReactClass');
const utils = require('./utils');

module.exports = function rule(context) {
  // Non-null when we are inside a React component ClassDeclaration and we have
  // not yet encountered any use of this.state which we have chosen not to
  // analyze. If we encounter any such usage (like this.state being spread as
  // JSX attributes), then this is again set to null.
  let classInfo = null;

  return {
    ClassDeclaration(node) {
      if (isReactClass(node)) {
        classInfo = {
          // if a state property initializer is found, record the node
          propertyInitializerNode: null,

          // if this.state is assigned in the constructor, record the node
          constructorInitializerNode: null,
        };
      }
    },

    'ClassDeclaration:exit'() {
      if (!classInfo) {
        return;
      }

      if (
        classInfo.propertyInitializerNode &&
        classInfo.constructorInitializerNode
      ) {
        // Shouldn't assign to state twice
        context.report(
          classInfo.propertyInitializerNode,
          'state was assigned to twice',
        );
      } else if (classInfo.constructorInitializerNode) {
        // Should use property initializer instead
        context.report(
          classInfo.constructorInitializerNode,
          'state should be initialized with a property initializer',
        );
      }

      classInfo = null;
    },

    ClassProperty(node) {
      if (!classInfo) {
        return;
      }
      // If we see state being assigned as a class property using an object
      // expression, remember that assignment.
      if (
        utils.getName(node.key) === 'state' &&
        !node.static &&
        node.value &&
        node.value.type === 'ObjectExpression'
      ) {
        classInfo.propertyInitializerNode = node;
      }
    },

    AssignmentExpression(node) {
      if (!classInfo) {
        return;
      }
      // Check for assignments like `this.state = {}`
      if (
        node.left.type === 'MemberExpression' &&
        utils.isThisExpression(node.left.object) &&
        utils.getName(node.left.property) === 'state' &&
        node.right.type === 'ObjectExpression'
      ) {
        // Find the nearest function expression containing this assignment.
        let fn = node;
        while (fn.type !== 'FunctionExpression' && fn.parent) {
          fn = fn.parent;
        }
        // If the nearest containing function is the constructor, remember that.
        if (
          fn.parent &&
          fn.parent.type === 'MethodDefinition' &&
          fn.parent.kind === 'constructor'
        ) {
          classInfo.constructorInitializerNode = node;
        }
      }

      // Future consideration: Check for assignments like `alias = this.state`
      // and record the alias. Without alias handling, this lint rule will
      // have false negatives.
    },
  };
};
