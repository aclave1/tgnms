/**
 * Generated by `js1 upgrade www-shared`.
 * @generated SignedSource<<77cd198d447bc47be30392c5d782dfaf>>
 *
 * Copyright 2004-present Facebook. All Rights Reserved.
 */

'use strict';

/**
 * There are two ways to write methods with classes:
 *  - Normal methods: class c { method() {} }
 *  - Autobound methods: class c { method = () => {} }
 *
 * In an ideal world, we would only have a single way to write methods that is
 * always autobound since this is what developers usually expect. Unfortunately,
 * autobound methods have a higher cost as they need to be allocated for every
 * single instance.
 *
 * This lint rule tries to ensure that autobound methods are only used when
 * strictly needed to guarantee code correctness. It will prompt you to
 * replace autobound methods by normal methods and vis-versa for all the common
 * cases.
 */

function isUnboundCall(node) {
  const parent = node.parent;

  // this.a()
  if (
    parent &&
    parent.type === 'CallExpression' &&
    parent.callee === node
  ) {
    return false;
  }

  // this.a.bind(this)
  if (
    parent &&
    parent.type === 'MemberExpression' &&
    !parent.computed &&
    parent.property &&
    parent.property.type === 'Identifier' && (
      parent.property.name === 'bind' ||
      parent.property.name === 'apply' ||
      parent.property.name === 'call'
    ) &&
    parent.parent &&
    parent.parent.type === 'CallExpression' &&
    parent.parent.arguments[0] &&
    parent.parent.arguments[0].type === 'ThisExpression'
  ) {
    return false;
  }

  return true;
}

function isArrowFunction(node) {
  return (
    node.type === 'ClassProperty' &&
    !node.computed &&
    !node.static &&
    node.key &&
    node.key.type === 'Identifier' &&
    node.value &&
    node.value.type === 'ArrowFunctionExpression' &&
    node.value.body.type &&
    node.value.body.type === 'BlockStatement'
  );
}

function isNormalFunction(node) {
  return (
    node.kind !== 'get' &&
    node.type === 'MethodDefinition' &&
    !node.computed &&
    !node.static &&
    node.key &&
    node.key.type === 'Identifier' &&
    node.value &&
    node.value.type === 'FunctionExpression'
  );
}

// This returns false when there's a normal function between the node and
// the method definition.
//
// false: class c { f() { function() { this } } }
// true: class c { f() { this } }
// true: class c { f() { () => this } }
// true: class c { f = () => { this } }
//
// Note that in the case where we have
//   class c { f() { function() { this }.bind(this) } }
// the inner this is going to return false but the outer one is going to be true
// and therefore the whole function is going to be marked as using this.
function checkUseOfThis(node) {
  while (node && node.type !== 'ClassBody') {
    if (
      node.type === 'FunctionExpression' ||
      node.type === 'FunctionDeclaration'
    ) {
      // If we found the method itself, we need to return true
      if (node.parent.type === 'MethodDefinition') {
        return true;
      }

      return false;
    }
    node = node.parent;
  }
  return true;
}

module.exports = function rule(context) {
  // The rule works by looking at every uses of `this` in the file but only
  // takes actions if it is inside of a method of a class. Therefore we do a
  // stateful traversal and fill the following variables in the process.
  let currentClass = null;
  const classes = [];
  // When we exit a class, we look at all the methods we found and how they
  // were called. If they happen to be called in a way that doesn't match their
  // "bound-ness", we trigger a lint rule to fix it to the correct one.

  return {
    ClassBody(node) {
      currentClass = {
        methods: new Map(),
        currentMethodName: null,
      };
      classes.push(currentClass);

      if (node.parent.typeParameters) {
        // There's currently a bug in Flow where arrow functions using class
        // generics trigger spurious flow errors.
        // https://github.com/facebook/flow/issues/2435
        //
        // There is a workaround to put the type outside but I decided to
        // instead ignore those for two reasons:
        // - given that eslint auto-fix is string based instead of
        //   ast it is a pretty difficult and dangerous change to make
        // - there aren't a lot of existing classes with generics in the
        //   codebase so it's not going to be a big issue.
        //
        // Once flow fixes it, we can just drop this condition and it'll work
        // well.
        return;
      }

      node.body
        .forEach(e => {
          const isArrow = isArrowFunction(e);

          if (!isArrow && !isNormalFunction(e)) {
            return;
          }

          let shouldAutofix = true;

          if (isArrow) {
            // ESLint 3/4 compatibility layer.
            const source = context.eslint
              ? context.eslint.getSource()
              : context.getSourceCode().getText();

            const definition = source.slice(e.value.start, e.value.body.start);

            if (definition.indexOf('/*') !== -1) {
              shouldAutofix = false;
            }
          }

          currentClass.methods.set(e.key.name, {
            isArrowFunction: isArrow,
            usesThis: false,
            hasUnboundCalls: false,
            isOverriden: false,
            node: e,
            shouldAutofix,
          });
        });
    },

    ClassProperty(node) {
      if (isArrowFunction(node)) {
        currentClass.currentMethodName = node.key.name;
      }
    },
    'ClassProperty:exit'() {
      currentClass.currentMethodName = null;
    },

    MethodDefinition(node) {
      if (isNormalFunction(node)) {
        currentClass.currentMethodName = node.key.name;
      }
    },
    'MethodDefinition:exit'() {
      currentClass.currentMethodName = null;
    },

    ThisExpression(node) {
      if (!currentClass) {
        return;
      }
      const methods = currentClass.methods;
      const currentMethodName = currentClass.currentMethodName;

      // Flag the current method as using this
      if (currentMethodName && methods.has(currentMethodName)) {
        const currentMethod = methods.get(currentMethodName);
        currentMethod.usesThis = currentMethod.usesThis || checkUseOfThis(node);
      }

      // If the this is not being used with the form `this.a` then bail
      const parent = node.parent;
      if (!(
        parent &&
        parent.type === 'MemberExpression' &&
        parent.property.type === 'Identifier' &&
        !parent.computed
      )) {
        return;
      }

      // If we're using an attribute of `this` that's not a method, we skip it
      const name = parent.property.name;
      if (!methods.has(name)) {
        return;
      }
      const method = methods.get(name);

      // this.a = ...
      if (
        parent.parent &&
        parent.parent.type === 'AssignmentExpression' &&
        parent.parent.left === parent
      ) {
        method.isOverriden = true;
      }

      // We check if the use of this is bound or not and decide what to do
      // based on the type of function
      if (isUnboundCall(parent)) {
        method.hasUnboundCalls = true;
      }
    },

    'ClassBody:exit'() {
      const methods = currentClass.methods;
      classes.pop();
      currentClass = classes[classes.length - 1];

      methods.forEach((method, name) => {
        // It doesn't make sense for constructor to be an arrow function and
        // there are calls of `this.constructor.something` which breaks our
        // heuristics. Ignoring constructor altogether fixes this problem.
        if (name === 'constructor') {
          return;
        }

        function report(message) {
          const node = method.node;
          context.report({
            node,
            message,
            fix: method.shouldAutofix &&
              fix.bind(null, context, node, method.isArrowFunction),
          });
        }

        // If the method has been overridden, assume that the author knows
        // what s/he is doing.
        if (method.isOverriden) {
          return;
        }

        if (method.isArrowFunction && !method.usesThis) {
          report(
            'This code uses property initializer syntax to make an autobound ' +
            'method, but the method doesn\'t use `this` so autobinding ' +
            'incurs an unnecessary performance hit. Prefer using a regular ' +
            'class method for this case.'
          );
          return;
        }

        if (method.isArrowFunction && !method.hasUnboundCalls) {
          report(
            'This code uses property initializer syntax to make an autobound ' +
            'method, but no uses of this function appear to require ' +
            'autobinding so autobinding incurs an unnecessary performance ' +
            'hit. Prefer using a regular class method for this case.'
          );
          return;
        }

        if (!method.isArrowFunction &&
            method.hasUnboundCalls &&
            method.usesThis) {
          report(
            'This method is not autobound, but it appears to be referenced ' +
            'in a way that requires autobinding in order to pass the correct ' +
            '`this` context. Did you mean to make an autobound method instead?'
          );
          return;
        }
      });
    },
  };
};

function fix(context, node, isArrow, fixer) {
  const sourceCode = context.getSourceCode();

  // Sadly ESLint fixer API only allows text manipulation and not AST one like
  // with our codemod tools. So, this code is going to be very fragile and I
  // hope it works...

  if (!isArrow) {
    // a() { }
    //  ^  ^
    //  |  node.value.body
    //  node.value

    const nodeCode = sourceCode.getText(node);
    const valueCode = sourceCode.getText(node.value);
    const code = sourceCode.text;
    const nodeStart = node.range[0];
    const valueStart = node.value.range[0];
    const valueEnd = node.value.range[1];
    const bodyStart = node.value.body.range[0];
    const shouldAddSemiColon = code[valueEnd] !== ';';
    const isAsync = node.value.async;

    return fixer.replaceTextRange(
      [nodeStart, valueEnd],
      nodeCode.slice(0, valueStart - nodeStart)
        .replace(isAsync ? /async[\s]*/ : '', '') +
      ' = ' +
      (isAsync ? 'async ' : '') +
      valueCode.slice(0, bodyStart - valueStart) + '=> ' +
      valueCode.slice(bodyStart - valueStart) +
      (shouldAddSemiColon ? ';' : '')
    );
  }

  // a = () => { };
  // ^         ^
  // node      node.value.body

  const nodeCode = sourceCode.getText(node);
  const nodeStart = node.range[0];
  const nodeEnd = node.range[1];
  const bodyStart = node.value.body.range[0];
  const isAsync = node.value.async;

  return fixer.replaceTextRange(
    [nodeStart, nodeEnd],
    (isAsync ? 'async ' : '') +
    nodeCode.slice(0, bodyStart - nodeStart)
      .replace(isAsync ? /async[\s]*/ : '', '') // remove 'async '
      .replace(/=\s*([^()]*?)\s*=>/, '= ($1) =>') // add ()
      .replace(/\s*=\s*/, '') // remove first ' = '
      .replace(/=>\s*$/, '') + // remove last '=> '
    nodeCode.slice(bodyStart - nodeStart)
      .replace(/;$/, '')
  );
}
