/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>

#include <thrift/lib/cpp2/GeneratedHeaderHelper.h>



namespace facebook { namespace terragraph { namespace thrift {

class Site;
class Node;
class Link;
class Topology;

enum class NodeType {
  CN = 1,
  DN = 2,
  POP = 3
};

extern const typename apache::thrift::detail::TEnumMapFactory<NodeType, NodeType>::ValuesToNamesMapType _NodeType_VALUES_TO_NAMES;
extern const typename apache::thrift::detail::TEnumMapFactory<NodeType, NodeType>::NamesToValuesMapType _NodeType_NAMES_TO_VALUES;

}}} // facebook::terragraph::thrift
namespace std {

template<> struct hash<typename  ::facebook::terragraph::thrift::NodeType> : public apache::thrift::detail::enum_hash<typename  ::facebook::terragraph::thrift::NodeType> {};
template<> struct equal_to<typename  ::facebook::terragraph::thrift::NodeType> : public apache::thrift::detail::enum_equal_to<typename  ::facebook::terragraph::thrift::NodeType> {};

} // std
namespace apache { namespace thrift {

template <> folly::Range<const std::pair< ::facebook::terragraph::thrift::NodeType, folly::StringPiece>*> TEnumTraitsBase< ::facebook::terragraph::thrift::NodeType>::enumerators();
template <> const char* TEnumTraitsBase< ::facebook::terragraph::thrift::NodeType>::findName( ::facebook::terragraph::thrift::NodeType value);
template <> bool TEnumTraitsBase< ::facebook::terragraph::thrift::NodeType>::findValue(const char* name,  ::facebook::terragraph::thrift::NodeType* outValue);

template <> constexpr  ::facebook::terragraph::thrift::NodeType TEnumTraits< ::facebook::terragraph::thrift::NodeType>::min() {
  return  ::facebook::terragraph::thrift::NodeType::CN;
}

template <> constexpr  ::facebook::terragraph::thrift::NodeType TEnumTraits< ::facebook::terragraph::thrift::NodeType>::max() {
  return  ::facebook::terragraph::thrift::NodeType::POP;
}

}} // apache::thrift
namespace facebook { namespace terragraph { namespace thrift {

enum class PolarityType {
  ODD = 1,
  EVEN = 2
};

extern const typename apache::thrift::detail::TEnumMapFactory<PolarityType, PolarityType>::ValuesToNamesMapType _PolarityType_VALUES_TO_NAMES;
extern const typename apache::thrift::detail::TEnumMapFactory<PolarityType, PolarityType>::NamesToValuesMapType _PolarityType_NAMES_TO_VALUES;

}}} // facebook::terragraph::thrift
namespace std {

template<> struct hash<typename  ::facebook::terragraph::thrift::PolarityType> : public apache::thrift::detail::enum_hash<typename  ::facebook::terragraph::thrift::PolarityType> {};
template<> struct equal_to<typename  ::facebook::terragraph::thrift::PolarityType> : public apache::thrift::detail::enum_equal_to<typename  ::facebook::terragraph::thrift::PolarityType> {};

} // std
namespace apache { namespace thrift {

template <> folly::Range<const std::pair< ::facebook::terragraph::thrift::PolarityType, folly::StringPiece>*> TEnumTraitsBase< ::facebook::terragraph::thrift::PolarityType>::enumerators();
template <> const char* TEnumTraitsBase< ::facebook::terragraph::thrift::PolarityType>::findName( ::facebook::terragraph::thrift::PolarityType value);
template <> bool TEnumTraitsBase< ::facebook::terragraph::thrift::PolarityType>::findValue(const char* name,  ::facebook::terragraph::thrift::PolarityType* outValue);

template <> constexpr  ::facebook::terragraph::thrift::PolarityType TEnumTraits< ::facebook::terragraph::thrift::PolarityType>::min() {
  return  ::facebook::terragraph::thrift::PolarityType::ODD;
}

template <> constexpr  ::facebook::terragraph::thrift::PolarityType TEnumTraits< ::facebook::terragraph::thrift::PolarityType>::max() {
  return  ::facebook::terragraph::thrift::PolarityType::EVEN;
}

}} // apache::thrift
namespace facebook { namespace terragraph { namespace thrift {

enum class LinkType {
  WIRELESS = 1,
  ETHERNET = 2
};

extern const typename apache::thrift::detail::TEnumMapFactory<LinkType, LinkType>::ValuesToNamesMapType _LinkType_VALUES_TO_NAMES;
extern const typename apache::thrift::detail::TEnumMapFactory<LinkType, LinkType>::NamesToValuesMapType _LinkType_NAMES_TO_VALUES;

}}} // facebook::terragraph::thrift
namespace std {

template<> struct hash<typename  ::facebook::terragraph::thrift::LinkType> : public apache::thrift::detail::enum_hash<typename  ::facebook::terragraph::thrift::LinkType> {};
template<> struct equal_to<typename  ::facebook::terragraph::thrift::LinkType> : public apache::thrift::detail::enum_equal_to<typename  ::facebook::terragraph::thrift::LinkType> {};

} // std
namespace apache { namespace thrift {

template <> folly::Range<const std::pair< ::facebook::terragraph::thrift::LinkType, folly::StringPiece>*> TEnumTraitsBase< ::facebook::terragraph::thrift::LinkType>::enumerators();
template <> const char* TEnumTraitsBase< ::facebook::terragraph::thrift::LinkType>::findName( ::facebook::terragraph::thrift::LinkType value);
template <> bool TEnumTraitsBase< ::facebook::terragraph::thrift::LinkType>::findValue(const char* name,  ::facebook::terragraph::thrift::LinkType* outValue);

template <> constexpr  ::facebook::terragraph::thrift::LinkType TEnumTraits< ::facebook::terragraph::thrift::LinkType>::min() {
  return  ::facebook::terragraph::thrift::LinkType::WIRELESS;
}

template <> constexpr  ::facebook::terragraph::thrift::LinkType TEnumTraits< ::facebook::terragraph::thrift::LinkType>::max() {
  return  ::facebook::terragraph::thrift::LinkType::ETHERNET;
}

}} // apache::thrift
namespace facebook { namespace terragraph { namespace thrift {

class Site : private apache::thrift::detail::st::ComparisonOperators<Site> {
 public:

  Site() :
      latitude(0),
      longitude(0),
      altitude(0) {}
  // FragileConstructor for use in initialization lists only

  Site(apache::thrift::FragileConstructor, std::string name__arg, double latitude__arg, double longitude__arg, double altitude__arg) :
      name(std::move(name__arg)),
      latitude(std::move(latitude__arg)),
      longitude(std::move(longitude__arg)),
      altitude(std::move(altitude__arg)) {
    __isset.name = true;
    __isset.latitude = true;
    __isset.longitude = true;
    __isset.altitude = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Site(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Site(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    name = arg.move();
    __isset.name = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Site(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Site(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    latitude = arg.move();
    __isset.latitude = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Site(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Site(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    longitude = arg.move();
    __isset.longitude = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Site(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Site(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    altitude = arg.move();
    __isset.altitude = true;
  }

  Site(Site&&) = default;

  Site(const Site&) = default;

  Site& operator=(Site&&) = default;

  Site& operator=(const Site&) = default;
  void __clear();

  virtual ~Site() throw() {}

  std::string name;
  double latitude;
  double longitude;
  double altitude;

  struct __isset {
    void __clear() {
      name = false;
      latitude = false;
      longitude = false;
      altitude = false;
    }

    bool name = false;
    bool latitude = false;
    bool longitude = false;
    bool altitude = false;
  } __isset;
  bool operator==(const Site& rhs) const;

  bool operator < (const Site& rhs) const {
    if (!(name == rhs.name)) {
      return name < rhs.name;
    }
    if (!(latitude == rhs.latitude)) {
      return latitude < rhs.latitude;
    }
    if (!(longitude == rhs.longitude)) {
      return longitude < rhs.longitude;
    }
    if (!(altitude == rhs.altitude)) {
      return altitude < rhs.altitude;
    }
    return false;
  }

  const std::string& get_name() const& {
    return name;
  }

  std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Site_name_struct_setter>
  std::string& set_name(T_Site_name_struct_setter&& name_) {
    name = std::forward<T_Site_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  double get_latitude() const {
    return latitude;
  }

  double& set_latitude(double latitude_) {
    latitude = latitude_;
    __isset.latitude = true;
    return latitude;
  }

  double get_longitude() const {
    return longitude;
  }

  double& set_longitude(double longitude_) {
    longitude = longitude_;
    __isset.longitude = true;
    return longitude;
  }

  double get_altitude() const {
    return altitude;
  }

  double& set_altitude(double altitude_) {
    altitude = altitude_;
    __isset.altitude = true;
    return altitude;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(Site& a, Site& b);
extern template uint32_t Site::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Site::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Site::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Site::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Site::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Site::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Site::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Site::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // facebook::terragraph::thrift
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::terragraph::thrift::Site>::clear( ::facebook::terragraph::thrift::Site* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::terragraph::thrift::Site>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Site>::write(Protocol* proto,  ::facebook::terragraph::thrift::Site const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Site>::read(Protocol* proto,  ::facebook::terragraph::thrift::Site* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Site>::serializedSize(Protocol const* proto,  ::facebook::terragraph::thrift::Site const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Site>::serializedSizeZC(Protocol const* proto,  ::facebook::terragraph::thrift::Site const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace terragraph { namespace thrift {

class Node : private apache::thrift::detail::st::ComparisonOperators<Node> {
 public:

  Node() :
      node_type( ::facebook::terragraph::thrift::NodeType()),
      is_primary(0),
      pop_node(0),
      is_ignited(0),
      polarity( ::facebook::terragraph::thrift::PolarityType()),
      ant_azimuth(0),
      ant_elevation(0) {}
  // FragileConstructor for use in initialization lists only

  Node(apache::thrift::FragileConstructor, std::string name__arg,  ::facebook::terragraph::thrift::NodeType node_type__arg, bool is_primary__arg, std::string mac_addr__arg, bool pop_node__arg, bool is_ignited__arg,  ::facebook::terragraph::thrift::PolarityType polarity__arg, std::string site_name__arg, double ant_azimuth__arg, double ant_elevation__arg) :
      name(std::move(name__arg)),
      node_type(std::move(node_type__arg)),
      is_primary(std::move(is_primary__arg)),
      mac_addr(std::move(mac_addr__arg)),
      pop_node(std::move(pop_node__arg)),
      is_ignited(std::move(is_ignited__arg)),
      polarity(std::move(polarity__arg)),
      site_name(std::move(site_name__arg)),
      ant_azimuth(std::move(ant_azimuth__arg)),
      ant_elevation(std::move(ant_elevation__arg)) {
    __isset.name = true;
    __isset.node_type = true;
    __isset.is_primary = true;
    __isset.mac_addr = true;
    __isset.pop_node = true;
    __isset.is_ignited = true;
    __isset.polarity = true;
    __isset.site_name = true;
    __isset.ant_azimuth = true;
    __isset.ant_elevation = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    name = arg.move();
    __isset.name = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    node_type = arg.move();
    __isset.node_type = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    is_primary = arg.move();
    __isset.is_primary = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    mac_addr = arg.move();
    __isset.mac_addr = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    pop_node = arg.move();
    __isset.pop_node = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    is_ignited = arg.move();
    __isset.is_ignited = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    polarity = arg.move();
    __isset.polarity = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<100, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    site_name = arg.move();
    __isset.site_name = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<101, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    ant_azimuth = arg.move();
    __isset.ant_azimuth = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Node(::apache::thrift::detail::argument_wrapper<102, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Node(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    ant_elevation = arg.move();
    __isset.ant_elevation = true;
  }

  Node(Node&&) = default;

  Node(const Node&) = default;

  Node& operator=(Node&&) = default;

  Node& operator=(const Node&) = default;
  void __clear();

  virtual ~Node() throw() {}

  std::string name;
   ::facebook::terragraph::thrift::NodeType node_type;
  bool is_primary;
  std::string mac_addr;
  bool pop_node;
  bool is_ignited;
   ::facebook::terragraph::thrift::PolarityType polarity;
  std::string site_name;
  double ant_azimuth;
  double ant_elevation;

  struct __isset {
    void __clear() {
      name = false;
      node_type = false;
      is_primary = false;
      mac_addr = false;
      pop_node = false;
      is_ignited = false;
      polarity = false;
      site_name = false;
      ant_azimuth = false;
      ant_elevation = false;
    }

    bool name = false;
    bool node_type = false;
    bool is_primary = false;
    bool mac_addr = false;
    bool pop_node = false;
    bool is_ignited = false;
    bool polarity = false;
    bool site_name = false;
    bool ant_azimuth = false;
    bool ant_elevation = false;
  } __isset;
  bool operator==(const Node& rhs) const;
  bool operator < (const Node& rhs) const;

  const std::string& get_name() const& {
    return name;
  }

  std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Node_name_struct_setter>
  std::string& set_name(T_Node_name_struct_setter&& name_) {
    name = std::forward<T_Node_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

   ::facebook::terragraph::thrift::NodeType get_node_type() const {
    return node_type;
  }

   ::facebook::terragraph::thrift::NodeType& set_node_type( ::facebook::terragraph::thrift::NodeType node_type_) {
    node_type = node_type_;
    __isset.node_type = true;
    return node_type;
  }

  const bool* get_is_primary() const& {
    return __isset.is_primary ? std::addressof(is_primary) : nullptr;
  }

  bool* get_is_primary() & {
    return __isset.is_primary ? std::addressof(is_primary) : nullptr;
  }
  bool* get_is_primary() && = delete;

  bool& set_is_primary(bool is_primary_) {
    is_primary = is_primary_;
    __isset.is_primary = true;
    return is_primary;
  }

  const std::string& get_mac_addr() const& {
    return mac_addr;
  }

  std::string get_mac_addr() && {
    return std::move(mac_addr);
  }

  template <typename T_Node_mac_addr_struct_setter>
  std::string& set_mac_addr(T_Node_mac_addr_struct_setter&& mac_addr_) {
    mac_addr = std::forward<T_Node_mac_addr_struct_setter>(mac_addr_);
    __isset.mac_addr = true;
    return mac_addr;
  }

  bool get_pop_node() const {
    return pop_node;
  }

  bool& set_pop_node(bool pop_node_) {
    pop_node = pop_node_;
    __isset.pop_node = true;
    return pop_node;
  }

  const bool* get_is_ignited() const& {
    return __isset.is_ignited ? std::addressof(is_ignited) : nullptr;
  }

  bool* get_is_ignited() & {
    return __isset.is_ignited ? std::addressof(is_ignited) : nullptr;
  }
  bool* get_is_ignited() && = delete;

  bool& set_is_ignited(bool is_ignited_) {
    is_ignited = is_ignited_;
    __isset.is_ignited = true;
    return is_ignited;
  }

  const  ::facebook::terragraph::thrift::PolarityType* get_polarity() const& {
    return __isset.polarity ? std::addressof(polarity) : nullptr;
  }

   ::facebook::terragraph::thrift::PolarityType* get_polarity() & {
    return __isset.polarity ? std::addressof(polarity) : nullptr;
  }
   ::facebook::terragraph::thrift::PolarityType* get_polarity() && = delete;

   ::facebook::terragraph::thrift::PolarityType& set_polarity( ::facebook::terragraph::thrift::PolarityType polarity_) {
    polarity = polarity_;
    __isset.polarity = true;
    return polarity;
  }

  const std::string* get_site_name() const& {
    return __isset.site_name ? std::addressof(site_name) : nullptr;
  }

  std::string* get_site_name() & {
    return __isset.site_name ? std::addressof(site_name) : nullptr;
  }
  std::string* get_site_name() && = delete;

  template <typename T_Node_site_name_struct_setter>
  std::string& set_site_name(T_Node_site_name_struct_setter&& site_name_) {
    site_name = std::forward<T_Node_site_name_struct_setter>(site_name_);
    __isset.site_name = true;
    return site_name;
  }

  const double* get_ant_azimuth() const& {
    return __isset.ant_azimuth ? std::addressof(ant_azimuth) : nullptr;
  }

  double* get_ant_azimuth() & {
    return __isset.ant_azimuth ? std::addressof(ant_azimuth) : nullptr;
  }
  double* get_ant_azimuth() && = delete;

  double& set_ant_azimuth(double ant_azimuth_) {
    ant_azimuth = ant_azimuth_;
    __isset.ant_azimuth = true;
    return ant_azimuth;
  }

  const double* get_ant_elevation() const& {
    return __isset.ant_elevation ? std::addressof(ant_elevation) : nullptr;
  }

  double* get_ant_elevation() & {
    return __isset.ant_elevation ? std::addressof(ant_elevation) : nullptr;
  }
  double* get_ant_elevation() && = delete;

  double& set_ant_elevation(double ant_elevation_) {
    ant_elevation = ant_elevation_;
    __isset.ant_elevation = true;
    return ant_elevation;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(Node& a, Node& b);
extern template uint32_t Node::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Node::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Node::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Node::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Node::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Node::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Node::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Node::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // facebook::terragraph::thrift
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::terragraph::thrift::Node>::clear( ::facebook::terragraph::thrift::Node* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::terragraph::thrift::Node>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Node>::write(Protocol* proto,  ::facebook::terragraph::thrift::Node const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Node>::read(Protocol* proto,  ::facebook::terragraph::thrift::Node* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Node>::serializedSize(Protocol const* proto,  ::facebook::terragraph::thrift::Node const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Node>::serializedSizeZC(Protocol const* proto,  ::facebook::terragraph::thrift::Node const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace terragraph { namespace thrift {

class Link : private apache::thrift::detail::st::ComparisonOperators<Link> {
 public:

  Link() :
      link_type( ::facebook::terragraph::thrift::LinkType()),
      is_alive(0),
      linkup_attempts(0) {}
  // FragileConstructor for use in initialization lists only

  Link(apache::thrift::FragileConstructor, std::string name__arg, std::string a_node_name__arg, std::string z_node_name__arg,  ::facebook::terragraph::thrift::LinkType link_type__arg, bool is_alive__arg, int64_t linkup_attempts__arg) :
      name(std::move(name__arg)),
      a_node_name(std::move(a_node_name__arg)),
      z_node_name(std::move(z_node_name__arg)),
      link_type(std::move(link_type__arg)),
      is_alive(std::move(is_alive__arg)),
      linkup_attempts(std::move(linkup_attempts__arg)) {
    __isset.name = true;
    __isset.a_node_name = true;
    __isset.z_node_name = true;
    __isset.link_type = true;
    __isset.is_alive = true;
    __isset.linkup_attempts = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Link(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Link(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    name = arg.move();
    __isset.name = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Link(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Link(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    a_node_name = arg.move();
    __isset.a_node_name = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Link(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Link(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    z_node_name = arg.move();
    __isset.z_node_name = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Link(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Link(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    link_type = arg.move();
    __isset.link_type = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Link(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Link(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    is_alive = arg.move();
    __isset.is_alive = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Link(::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Link(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    linkup_attempts = arg.move();
    __isset.linkup_attempts = true;
  }

  Link(Link&&) = default;

  Link(const Link&) = default;

  Link& operator=(Link&&) = default;

  Link& operator=(const Link&) = default;
  void __clear();

  virtual ~Link() throw() {}

  std::string name;
  std::string a_node_name;
  std::string z_node_name;
   ::facebook::terragraph::thrift::LinkType link_type;
  bool is_alive;
  int64_t linkup_attempts;

  struct __isset {
    void __clear() {
      name = false;
      a_node_name = false;
      z_node_name = false;
      link_type = false;
      is_alive = false;
      linkup_attempts = false;
    }

    bool name = false;
    bool a_node_name = false;
    bool z_node_name = false;
    bool link_type = false;
    bool is_alive = false;
    bool linkup_attempts = false;
  } __isset;
  bool operator==(const Link& rhs) const;
  bool operator < (const Link& rhs) const;

  const std::string& get_name() const& {
    return name;
  }

  std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Link_name_struct_setter>
  std::string& set_name(T_Link_name_struct_setter&& name_) {
    name = std::forward<T_Link_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  const std::string& get_a_node_name() const& {
    return a_node_name;
  }

  std::string get_a_node_name() && {
    return std::move(a_node_name);
  }

  template <typename T_Link_a_node_name_struct_setter>
  std::string& set_a_node_name(T_Link_a_node_name_struct_setter&& a_node_name_) {
    a_node_name = std::forward<T_Link_a_node_name_struct_setter>(a_node_name_);
    __isset.a_node_name = true;
    return a_node_name;
  }

  const std::string& get_z_node_name() const& {
    return z_node_name;
  }

  std::string get_z_node_name() && {
    return std::move(z_node_name);
  }

  template <typename T_Link_z_node_name_struct_setter>
  std::string& set_z_node_name(T_Link_z_node_name_struct_setter&& z_node_name_) {
    z_node_name = std::forward<T_Link_z_node_name_struct_setter>(z_node_name_);
    __isset.z_node_name = true;
    return z_node_name;
  }

   ::facebook::terragraph::thrift::LinkType get_link_type() const {
    return link_type;
  }

   ::facebook::terragraph::thrift::LinkType& set_link_type( ::facebook::terragraph::thrift::LinkType link_type_) {
    link_type = link_type_;
    __isset.link_type = true;
    return link_type;
  }

  const bool* get_is_alive() const& {
    return __isset.is_alive ? std::addressof(is_alive) : nullptr;
  }

  bool* get_is_alive() & {
    return __isset.is_alive ? std::addressof(is_alive) : nullptr;
  }
  bool* get_is_alive() && = delete;

  bool& set_is_alive(bool is_alive_) {
    is_alive = is_alive_;
    __isset.is_alive = true;
    return is_alive;
  }

  const int64_t* get_linkup_attempts() const& {
    return __isset.linkup_attempts ? std::addressof(linkup_attempts) : nullptr;
  }

  int64_t* get_linkup_attempts() & {
    return __isset.linkup_attempts ? std::addressof(linkup_attempts) : nullptr;
  }
  int64_t* get_linkup_attempts() && = delete;

  int64_t& set_linkup_attempts(int64_t linkup_attempts_) {
    linkup_attempts = linkup_attempts_;
    __isset.linkup_attempts = true;
    return linkup_attempts;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(Link& a, Link& b);
extern template uint32_t Link::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Link::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Link::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Link::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Link::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Link::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Link::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Link::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // facebook::terragraph::thrift
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::terragraph::thrift::Link>::clear( ::facebook::terragraph::thrift::Link* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::terragraph::thrift::Link>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Link>::write(Protocol* proto,  ::facebook::terragraph::thrift::Link const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Link>::read(Protocol* proto,  ::facebook::terragraph::thrift::Link* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Link>::serializedSize(Protocol const* proto,  ::facebook::terragraph::thrift::Link const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Link>::serializedSizeZC(Protocol const* proto,  ::facebook::terragraph::thrift::Link const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace terragraph { namespace thrift {

class Topology : private apache::thrift::detail::st::ComparisonOperators<Topology> {
 public:

  Topology() {}
  // FragileConstructor for use in initialization lists only

  Topology(apache::thrift::FragileConstructor, std::string name__arg, std::vector< ::facebook::terragraph::thrift::Node> nodes__arg, std::vector< ::facebook::terragraph::thrift::Link> links__arg, std::vector< ::facebook::terragraph::thrift::Site> sites__arg) :
      name(std::move(name__arg)),
      nodes(std::move(nodes__arg)),
      links(std::move(links__arg)),
      sites(std::move(sites__arg)) {
    __isset.name = true;
    __isset.nodes = true;
    __isset.links = true;
    __isset.sites = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Topology(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Topology(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    name = arg.move();
    __isset.name = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Topology(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Topology(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    nodes = arg.move();
    __isset.nodes = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Topology(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Topology(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    links = arg.move();
    __isset.links = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Topology(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Topology(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    sites = arg.move();
    __isset.sites = true;
  }

  Topology(Topology&&) = default;

  Topology(const Topology&) = default;

  Topology& operator=(Topology&&) = default;

  Topology& operator=(const Topology&) = default;
  void __clear();

  virtual ~Topology() throw() {}

  std::string name;
  std::vector< ::facebook::terragraph::thrift::Node> nodes;
  std::vector< ::facebook::terragraph::thrift::Link> links;
  std::vector< ::facebook::terragraph::thrift::Site> sites;

  struct __isset {
    void __clear() {
      name = false;
      nodes = false;
      links = false;
      sites = false;
    }

    bool name = false;
    bool nodes = false;
    bool links = false;
    bool sites = false;
  } __isset;
  bool operator==(const Topology& rhs) const;
  bool operator < (const Topology& rhs) const;

  const std::string& get_name() const& {
    return name;
  }

  std::string get_name() && {
    return std::move(name);
  }

  template <typename T_Topology_name_struct_setter>
  std::string& set_name(T_Topology_name_struct_setter&& name_) {
    name = std::forward<T_Topology_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const std::vector< ::facebook::terragraph::thrift::Node>& get_nodes() const&;
  std::vector< ::facebook::terragraph::thrift::Node> get_nodes() &&;
  template <typename T_Topology_nodes_struct_setter>
  std::vector< ::facebook::terragraph::thrift::Node>& set_nodes(T_Topology_nodes_struct_setter&& nodes_);
  const std::vector< ::facebook::terragraph::thrift::Link>& get_links() const&;
  std::vector< ::facebook::terragraph::thrift::Link> get_links() &&;
  template <typename T_Topology_links_struct_setter>
  std::vector< ::facebook::terragraph::thrift::Link>& set_links(T_Topology_links_struct_setter&& links_);
  const std::vector< ::facebook::terragraph::thrift::Site>& get_sites() const&;
  std::vector< ::facebook::terragraph::thrift::Site> get_sites() &&;
  template <typename T_Topology_sites_struct_setter>
  std::vector< ::facebook::terragraph::thrift::Site>& set_sites(T_Topology_sites_struct_setter&& sites_);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(Topology& a, Topology& b);
extern template uint32_t Topology::read<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Topology::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Topology::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Topology::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Topology::read<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Topology::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Topology::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Topology::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}}} // facebook::terragraph::thrift
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::terragraph::thrift::Topology>::clear( ::facebook::terragraph::thrift::Topology* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::terragraph::thrift::Topology>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Topology>::write(Protocol* proto,  ::facebook::terragraph::thrift::Topology const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Topology>::read(Protocol* proto,  ::facebook::terragraph::thrift::Topology* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Topology>::serializedSize(Protocol const* proto,  ::facebook::terragraph::thrift::Topology const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::terragraph::thrift::Topology>::serializedSizeZC(Protocol const* proto,  ::facebook::terragraph::thrift::Topology const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace terragraph { namespace thrift {

}}} // facebook::terragraph::thrift
