#!/usr/bin/env python3
# Copyright 2004-present Facebook. All Rights Reserved.

import asyncio
import logging
import json

from datetime import datetime, timedelta
from dateutil import tz
from croniter import croniter
from dataclasses import dataclass, asdict, field

from module.base_classes import Job
from typing import List, Dict, Type

PRIORITY_TO_SEC = 0.001


@dataclass
class Empty:
    pass


@dataclass
class ScheduleConfig:
    """Fields that define the schedule

    - id - unique id generated by code
    - created_at - generated by code when an entry is created
    - cron entries (minutes, hours, ...)
    - job - class the defines the job
    - priority (0,1,2,3, ...) - if two jobs are scheduled for the same time,
      highest priority wins (0 is the highest priority)
    """

    cron_minute: str = "*"
    cron_hour: str = "*"
    cron_day_of_month: str = "*"
    cron_month: str = "*"
    cron_day_of_week: str = "*"
    cron_seconds: str = "0"
    priority: int = 0
    id: int = 0
    created_at: int = 0
    job: Job = field(default_factory=Job)


@dataclass
class ScheduleTop:
    """Top level schedule definition
    - next_id - similar to auto_increment in mysql, keeps track of unique id
    - schedules - list of objects of type ScheduleConfig
     """

    next_id: int = 1
    schedules: List[ScheduleConfig] = field(default_factory=list)


def _dict2class(st_dict: dict) -> ScheduleTop:
    """Utility function to convert ScheduleTop dict to obj"""
    st_obj = ScheduleTop(**st_dict)
    for index, schedule in enumerate(st_dict["schedules"]):
        st_obj.schedules[index] = ScheduleConfig(**schedule)
        job_obj = Job(**schedule["job"])
        st_obj.schedules[index].job = job_obj
    return st_obj


class Scheduler:
    """
        This is a cron-based scheduler. It uses asyncio to schedule jobs
        and croniter to read cron entries. It assumes there is a file
        with the schedule in json format.

        cron entries are UTC time

        A cron entry is either a * or a list for each field (minute, hour ...)
        examples:
        0 4,5 * * * 0 - run every day at 4am and at 5am
        30 * * * * 0 - run every hour on the half hour
        20 14 * * mon-fri 0  - run every weekday at 2:20pm
        * * * * * */5 - run every 5s
        Note that seconds is not standard cron but is supported by croniter.
        Set seconds to 0 if you don't want to use it (default)

        The operation works as follows:
        1. read the list of scheduled tests and schedule them
        2. when it's time, scheduler will put kwargs on the queue
        """

    def __init__(self, json_file: str, aio_queue: asyncio.PriorityQueue) -> None:
        self.json_file: str = json_file
        self.aio_queue: type[asyncio.PriorityQueue] = aio_queue
        self.timer_handle: dict = {}
        self.schedule: object = ScheduleTop()

        # schedule is a dict with a list of schedules
        # {"next_id" : n, "schedules" : []}
        logging.info("Starting scheduler ...")
        self._read_scheduler_file()
        self._schedule_tests()

    async def _async_enqueue(self, job: Type[Job], id: int, priority: int) -> None:
        """Put the job on the queue and remove the job id from the asyncio
        call_later list
        """
        # timestamp() returns time since epoch: e.g. 1565026044.774551
        # timestamp() assumes that datetime is local time
        job.start_time = datetime.now().timestamp()
        logging.debug(f"Putting job {id} on the queue")
        await self.aio_queue.put((priority, job))
        del self.timer_handle[id]
        self._schedule_tests()

    def _enqueue(self, sf_obj: ScheduleConfig) -> None:
        """For transition from sync to async world"""
        asyncio.create_task(self._async_enqueue(sf_obj.job, sf_obj.id, sf_obj.priority))

    def _read_scheduler_file(self) -> None:
        """Reads the file that contains information about the schedule. If the
        file does not exist, create it with a blank schedule
        """
        try:
            with open(self.json_file) as f:
                self.schedule = _dict2class(json.load(f))
        except FileNotFoundError:
            logging.info(f"Creating new file '{self.json_file}'")
            # blank schedule
            self.schedule = ScheduleTop()
            self._write_scheduler_file()
        except Exception as e:
            logging.error(f"Invalid JSON read scheduler {str(e)}")

    def _write_scheduler_file(self) -> None:
        """Writes current schedule to a file so that schedule will persist."""
        with open(self.json_file, "w") as f:
            try:
                json.dump(asdict(self.schedule), f)
            except Exception as e:
                logging.error(f"Invalid JSON write scheduler {str(e)}")

    def add_schedule(self, sf_obj: ScheduleConfig) -> bool:
        """Add schedule to the job queue. Updates file on disk
        Missing fields will be filled with default values
        """
        id = self.schedule.next_id
        if not self._verify_schedule(sf_obj):
            logging.error("Invalid schedule - returning")
            return False
        sf_obj.id = id
        # created_at is for information
        sf_obj.created_at = datetime.utcnow().strftime("%d %b %Y %H:%M:%S (UTC)")
        self.schedule.schedules.append(sf_obj)
        self.schedule.next_id = id + 1
        # params should be a dataclass; if it's left empty, assign to Empty()
        if sf_obj.job.params.__eq__(Empty()):
            sf_obj.job.params = Empty()
        self._write_scheduler_file()
        self._schedule_tests()
        return True

    def read_schedule(self) -> List[ScheduleConfig]:
        """Returns schedule as a python list"""
        return self.schedule.schedules

    def remove_schedules(self, id_list: List[int]) -> bool:
        """Remove list of ids from the schedule"""
        found = False
        for index, sch_obj in enumerate(self.schedule.schedules):
            if sch_obj.id in id_list:
                found = True
                id = sch_obj.id
                if id in self.timer_handle:
                    logging.info(f"Removed job {id} from job queue")
                    self.timer_handle[id].cancel()
                    del self.timer_handle[id]
                del self.schedule.schedules[index]
        if found:
            self._write_scheduler_file()
        else:
            logging.error(f"None of the ids on the list are in the schedule")
        return found

    def cancel_all(self) -> None:
        """Cancels all running schedules and resets file"""
        for handle in self.timer_handle.values():
            handle.cancel()
        self.timer_handle = {}
        # blank schedule
        self.schedule = ScheduleTop()
        self._write_scheduler_file()

    def _verify_schedule(self, sf_obj: ScheduleConfig) -> bool:
        """Given a description of the schedule, verify that cron entries are
        valid.
        """
        cron_list = [str(getattr(sf_obj, a)) for a in sf_obj.__dict__ if "cron" in a]
        cron_str = " ".join(cron_list)
        if not croniter.is_valid(cron_str):
            logging.error(f"cron format is not valid {cron_str}")
            return False
        return True

    def fill_in_blank_schedule(self) -> ScheduleConfig:
        """Function provided to facilitate creating a schedule"""
        # start time is filled in with current time when enqueued
        sch_obj = ScheduleConfig(job=Job(name="blank", start_time=0))
        return sch_obj

    def _print_queue(self) -> None:
        """Only used for debug prints"""
        if len(self.timer_handle):
            loop = asyncio.get_event_loop()
            for id, handle in self.timer_handle.items():
                delay = handle.when() - loop.time()
                tm = datetime.now()
                tm += timedelta(seconds=delay)
                start_time_str = tm.strftime("%d %b %Y %H:%M:%S (local)")
                logging.info(
                    f"Event scheduled at {start_time_str} test schedule id {id}"
                )
        else:
            logging.info("There are no scheduled jobs")

    # schedule a test if the test is not already scheduled
    def _schedule_tests(self) -> None:
        """Loop through all of the schedules (type ScheduleConfig); if the
        schedule is not currently being awaited, then calculate the next
        time the job will run and call loop.call_later which will call
        self._enqueue() at the next scheduled time

        cron time is UTC. This is so that programming the schedule is not 
        timezone dependent. 
        """
        baseutc = datetime.utcnow()

        for schedule in self.schedule.schedules:
            # only add new rows into the schedule
            if not schedule.id in self.timer_handle:
                cron_list = [
                    str(getattr(schedule, a)) for a in schedule.__dict__ if "cron" in a
                ]
                cron_str = " ".join(cron_list)
                iter = croniter(cron_str, baseutc)
                next = iter.get_next(datetime)
                delay_dt = next - baseutc
                delay_sec = delay_dt.total_seconds()

                start_time = baseutc + delay_dt
                start_time = start_time.replace(tzinfo=tz.tzutc())
                start_time_local = start_time.astimezone(tz.tzlocal())

                start_time_str = start_time.strftime("%d %b %Y %H:%M:%S (UTC)")
                start_time_str_local = start_time_local.strftime(
                    "%d %b %Y %H:%M:%S (local)"
                )
                logging.info(
                    f"Adding job {schedule.id} to job queue to start at "
                    f"{start_time_str} ({start_time_str_local})"
                )

                # use delay to signal priority
                # even though we are using a priority queue, a loop awaits on the
                # priority queue so we still want to write them in order
                delay_sec += schedule.priority * PRIORITY_TO_SEC
                logging.debug(f"Delay of call_later is {delay_sec}.")
                loop = asyncio.get_event_loop()
                self.timer_handle[schedule.id] = loop.call_later(
                    delay_sec, self._enqueue, schedule
                )

        self._print_queue()
